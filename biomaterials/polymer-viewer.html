<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Polymer Chain Viewer</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family:'Segoe UI',Tahoma,sans-serif;
      background:#12131a; color:#dde1f0;
      display:flex; height:100vh; overflow:hidden;
    }
    /* â”€â”€ sidebar â”€â”€ */
    #sidebar {
      width:295px; min-width:295px;
      background:#1a1d2e; border-right:1px solid #2a2d45;
      display:flex; flex-direction:column; gap:10px;
      padding:14px 13px; overflow-y:auto;
    }
    #sidebar h1 {
      font-size:.88rem; font-weight:700; color:#7eb8f7;
      text-transform:uppercase; letter-spacing:2px;
      border-bottom:1px solid #2a2d45; padding-bottom:9px;
    }
    .sec-label {
      font-size:.62rem; font-weight:700; color:#5a6080;
      text-transform:uppercase; letter-spacing:1.5px; margin-bottom:4px;
    }
    /* category header with coloured left border */
    .cat-label {
      font-size:.64rem; font-weight:700;
      text-transform:uppercase; letter-spacing:1.3px;
      margin-bottom:4px; padding-left:7px;
    }
    .cat-label.addition    { color:#7fbfff; border-left:3px solid #3366cc; }
    .cat-label.condensation{ color:#ffcc66; border-left:3px solid #cc8800; }

    .poly-grid { display:grid; grid-template-columns:1fr 1fr; gap:4px; }
    .poly-btn {
      padding:6px 3px; background:#1e2238;
      border:1px solid #2e3355; border-radius:7px;
      color:#9ba8c8; cursor:pointer;
      font-size:.68rem; font-weight:600; text-align:center; line-height:1.3;
      transition:background .15s,border-color .15s,color .15s;
    }
    .poly-btn:hover { background:#253060; border-color:#4a6bcc; color:#c8d8ff; }
    .poly-btn.active.addition    { background:#162a52; border-color:#4a79ff; color:#aad0ff; }
    .poly-btn.active.condensation{ background:#3a2800; border-color:#cc8800; color:#ffcc44; }
    .poly-btn small { font-size:.60rem; opacity:.72; display:block; }
    .poly-btn.disabled {
      opacity:.38; cursor:not-allowed; pointer-events:none;
      border-style:dashed;
    }
    /* â”€â”€ conformation selector â”€â”€ */
    .conf-row { display:flex; gap:5px; }
    .conf-btn {
      flex:1; padding:7px 4px; background:#1e2238;
      border:1px solid #2e3355; border-radius:7px;
      color:#9ba8c8; cursor:pointer; font-size:.72rem; font-weight:700;
      text-align:center; transition:background .15s,border-color .15s,color .15s;
    }
    .conf-btn:hover { background:#253060; border-color:#4a6bcc; color:#c8d8ff; }
    .conf-btn.active.crystal   { background:#122a4a; border-color:#4a99ff; color:#88ccff; }
    .conf-btn.active.amorphous { background:#3a2a0a; border-color:#dd9900; color:#ffcc44; }
    /* â”€â”€ slider â”€â”€ */
    .slider-row { display:flex; align-items:center; gap:8px; }
    .slider-row label { font-size:.72rem; color:#6878a0; white-space:nowrap; }
    input[type=range] { flex:1; accent-color:#4a79ff; cursor:pointer; }
    .sval { font-size:.80rem; color:#c8d8ff; font-weight:700; min-width:28px; text-align:right; }
    /* â”€â”€ toggle buttons â”€â”€ */
    .tgl-btn {
      width:100%; padding:6px 4px; background:#1e2238;
      border:1px solid #2e3355; border-radius:7px;
      color:#9ba8c8; cursor:pointer; font-size:.70rem; font-weight:600;
      transition:background .15s,border-color .15s,color .15s;
    }
    .tgl-btn:hover { background:#253060; border-color:#4a6bcc; color:#c8d8ff; }
    .tgl-btn.on.teal   { background:#0a4a3a; border-color:#00ddaa; color:#99ffee; }
    .tgl-btn.on.violet { background:#3a0a5a; border-color:#cc66ff; color:#eeccff; }
    .tgl-btn.on.amber  { background:#5a4000; border-color:#ffaa00; color:#ffe080; }
    .btn-row { display:flex; gap:5px; }
    .btn-row .tgl-btn { flex:1; }
    /* â”€â”€ info panel â”€â”€ */
    .info-panel {
      background:#1e2238; border:1px solid #2a2d45;
      border-radius:8px; padding:9px 11px; font-size:.76rem; line-height:1.85;
    }
    .info-row { display:flex; justify-content:space-between; align-items:baseline; gap:4px; }
    .info-key { color:#5a6080; font-size:.66rem; white-space:nowrap; }
    .info-val { color:#c8d8ff; font-weight:600; font-size:.70rem; text-align:right; }
    .info-desc {
      margin-top:6px; font-size:.67rem; color:#8890aa; line-height:1.5;
      border-top:1px solid #2a2d45; padding-top:6px;
    }
    /* â”€â”€ legend â”€â”€ */
    .legend { display:flex; flex-wrap:wrap; gap:5px; }
    .leg-item { display:flex; align-items:center; gap:4px; font-size:.66rem; color:#8890aa; }
    .leg-dot  { width:9px; height:9px; border-radius:50%; flex-shrink:0; }
    /* â”€â”€ controls hint â”€â”€ */
    .ctrl-hint { font-size:.67rem; color:#424a62; line-height:1.85; }
    .ctrl-hint b { color:#565f78; }
    /* â”€â”€ canvas â”€â”€ */
    #canvas-wrap { flex:1; position:relative; overflow:hidden; }
    #canvas-wrap canvas { display:block; }
    .badge {
      position:absolute; top:12px; right:14px;
      background:rgba(39,81,184,.22); border:1px solid #2751b8;
      border-radius:5px; padding:4px 13px; font-size:.70rem; color:#7eb8f7;
      pointer-events:none; user-select:none;
      transition:background .2s,border-color .2s,color .2s;
    }
    .badge.amorphous { background:rgba(80,55,0,.28); border-color:#886600; color:#ddaa33; }
    .badge.condensation { background:rgba(60,40,0,.28); border-color:#997700; color:#ffcc44; }
    .badge.condensation.amorphous { background:rgba(50,30,0,.35); border-color:#aa7700; color:#ffdd44; }
    .atom-count-badge {
      position:absolute; bottom:14px; right:14px;
      background:rgba(20,24,40,.70); border:1px solid #2a2d45;
      border-radius:5px; padding:3px 11px; font-size:.66rem; color:#5a6580;
      pointer-events:none; user-select:none;
    }
    .perf-warn {
      position:absolute; bottom:40px; right:14px;
      background:rgba(55,30,0,.85); border:1px solid #aa6600;
      border-radius:5px; padding:3px 11px; font-size:.63rem; color:#cc9933;
      pointer-events:none; user-select:none; display:none;
    }
    .chunk-note {
      font-size:.63rem; color:#3a4060; text-align:center;
      border-top:1px solid #242840; padding-top:6px; line-height:1.6;
    }
  </style>
</head>
<body>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SIDEBAR â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="sidebar">
  <h1>ğŸ”¬ Polymer Viewer</h1>

  <!-- â”€â”€ ADDITION POLYMERS â”€â”€ -->
  <div>
    <div class="cat-label addition">Addition / Chain-Growth</div>
    <div class="poly-grid">
      <button class="poly-btn addition active" data-key="PE"   data-cat="addition">Poly-<br>ethylene<br><small>Simplest chain</small></button>
      <button class="poly-btn addition"        data-key="aPP"  data-cat="addition">Atactic<br>PP<br><small>Random coil</small></button>
      <button class="poly-btn addition"        data-key="iPP"  data-cat="addition">Isotactic<br>PP<br><small>3â‚ helix</small></button>
      <button class="poly-btn addition"        data-key="aPS"  data-cat="addition">Atactic<br>PS<br><small>Random coil</small></button>
      <button class="poly-btn addition"        data-key="iPS"  data-cat="addition">Isotactic<br>PS<br><small>3â‚ helix</small></button>
      <button class="poly-btn addition"        data-key="PVC"  data-cat="addition">PVC<br><small>Atactic</small></button>
      <button class="poly-btn addition"        data-key="PMMA" data-cat="addition">PMMA<br><small>Atactic</small></button>
      <button class="poly-btn addition"        data-key="PTFE" data-cat="addition">PTFE<br><small>13â‚† helix</small></button>
      <button class="poly-btn addition"        data-key="PI"   data-cat="addition">Poly-<br>isoprene<br><small>cis-1,4</small></button>
      <button class="poly-btn addition"        data-key="pHEMA" data-cat="addition">pHEMA<br><small>Hydroxyethyl</small></button>
    </div>
  </div>

  <!-- â”€â”€ CONDENSATION / STEP-GROWTH POLYMERS â”€â”€ -->
  <div>
    <div class="cat-label condensation">Condensation / Step-Growth</div>
    <div class="poly-grid">
      <button class="poly-btn condensation" data-key="iPLA"   data-cat="condensation">Isotactic<br>PLA<br><small>10â‚ƒ helix</small></button>
      <button class="poly-btn condensation" data-key="Nylon66" data-cat="condensation">Nylon<br>6,6<br><small>Extended</small></button>
      <button class="poly-btn condensation" data-key="PDMS"   data-cat="condensation">PDMS<br><small>4â‚ helix</small></button>
      <button class="poly-btn condensation" data-key="PEO"    data-cat="condensation">PEO<br><small>7â‚‚ helix</small></button>
      <button class="poly-btn condensation" data-key="PET"  data-cat="condensation">PET<br><small>Aromatic ester</small></button>
      <button class="poly-btn condensation" data-key="PEEK" data-cat="condensation">PEEK<br><small>3 rings/mer</small></button>
    </div>
  </div>

  <!-- â”€â”€ CONFORMATION TOGGLE â”€â”€ -->
  <div>
    <div class="sec-label">Conformation</div>
    <div class="conf-row">
      <button class="conf-btn active crystal"   id="btn-crystal">ğŸ”· Crystal</button>
      <button class="conf-btn amorphous"        id="btn-amor">â˜ Amorphous</button>
    </div>
  </div>

  <!-- â”€â”€ CHAIN LENGTH â”€â”€ -->
  <div>
    <div class="sec-label">Chain Length (N mer units)</div>
    <div class="slider-row">
      <label>N =</label>
      <input type="range" id="mer-slider" min="1" max="200" value="30"/>
      <span class="sval" id="mer-val">30</span>
    </div>
  </div>

  <!-- â”€â”€ DISPLAY TOGGLES â”€â”€ -->
  <div>
    <div class="sec-label">Display</div>
    <div style="display:flex;flex-direction:column;gap:4px;">
      <div class="btn-row">
        <button class="tgl-btn teal"   id="btn-H">Show H Atoms</button>
        <button class="tgl-btn violet" id="btn-spin">Auto Spin</button>
      </div>
      <div class="btn-row">
        <button class="tgl-btn teal"  id="btn-backbone">Backbone Only</button>
        <button class="tgl-btn amber" id="btn-mers">Colour Mers</button>
      </div>
    </div>
  </div>

  <!-- â”€â”€ CPK LEGEND â”€â”€ -->
  <div>
    <div class="sec-label">CPK Colour Key</div>
    <div class="legend">
      <div class="leg-item"><div class="leg-dot" style="background:#909090"></div>C</div>
      <div class="leg-item"><div class="leg-dot" style="background:#e0e0e0"></div>H</div>
      <div class="leg-item"><div class="leg-dot" style="background:#ff4444"></div>O</div>
      <div class="leg-item"><div class="leg-dot" style="background:#4477ff"></div>N</div>
      <div class="leg-item"><div class="leg-dot" style="background:#00cc00"></div>Cl</div>
      <div class="leg-item"><div class="leg-dot" style="background:#80ffff"></div>F</div>
      <div class="leg-item"><div class="leg-dot" style="background:#c8a050"></div>Si</div>
    </div>
  </div>

  <!-- â”€â”€ STRUCTURE INFO â”€â”€ -->
  <div>
    <div class="sec-label">Structure Info</div>
    <div class="info-panel">
      <div class="info-row"><span class="info-key">Polymer</span>      <span class="info-val" id="inf-name">â€”</span></div>
      <div class="info-row"><span class="info-key">Formula</span>      <span class="info-val" id="inf-formula">â€”</span></div>
      <div class="info-row"><span class="info-key">Synthesis</span>    <span class="info-val" id="inf-synth">â€”</span></div>
      <div class="info-row"><span class="info-key">Conformation</span> <span class="info-val" id="inf-conf">â€”</span></div>
      <div class="info-row"><span class="info-key">Tg</span>           <span class="info-val" id="inf-tg">â€”</span></div>
      <div class="info-row"><span class="info-key">Tm</span>           <span class="info-val" id="inf-tm">â€”</span></div>
      <div class="info-row"><span class="info-key">Density</span>      <span class="info-val" id="inf-density">â€”</span></div>
      <div class="info-desc" id="inf-desc"></div>
    </div>
  </div>

  <!-- â”€â”€ CONTROLS â”€â”€ -->
  <div>
    <div class="ctrl-hint">
      <b>Left drag</b> â€” Rotate Â· <b>Right drag</b> â€” Pan<br>
      <b>Scroll</b> â€” Zoom Â· <b>Dbl-click</b> â€” Reset camera
    </div>
  </div>

  <div class="chunk-note">2D structural formula view â€” coming soon</div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CANVAS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="canvas-wrap">
  <div class="badge" id="badge">aPP Â· Atactic</div>
  <div class="perf-warn" id="perf-warn">âš  Large chain â€” reduced render quality</div>
  <div class="atom-count-badge" id="atom-count-badge"></div>
</div>

<!-- Three.js r128 + OrbitControls -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
'use strict';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONSTANTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const DEG = Math.PI / 180;
const T   = 180 * DEG;   // trans / anti     (IUPAC Ï‰ = 180Â°)
const Gp  =  60 * DEG;   // gauche-plus       (IUPAC Ï‰ = +60Â°)
const Gm  = -60 * DEG;   // gauche-minus      (IUPAC Ï‰ = âˆ’60Â°)

// CPK element colours and ball-and-stick radii (Ã…)
const ELEM = {
  C:  { color: 0x909090, r: 0.37 },
  H:  { color: 0xe0e0e0, r: 0.24 },
  O:  { color: 0xff4444, r: 0.34 },
  N:  { color: 0x4477ff, r: 0.35 },
  Cl: { color: 0x00cc00, r: 0.48 },
  F:  { color: 0x80ffff, r: 0.29 },
  Si: { color: 0xc8a050, r: 0.51 },   // golden-tan
};

const MER_COLORS = [0x5588cc, 0xe07744];

// â”€â”€â”€ Adaptive rendering quality â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _ql = 0;
function getSphereSegs() { return _ql === 0 ? [14,10] : _ql === 1 ? [10,7] : [8,6]; }
function getCylSegs()    { return _ql === 0 ? 7 : _ql === 1 ? 6 : 5; }

// â”€â”€â”€ Geometry / material cache â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const _geoCache = {};
function sphereGeo(r, ws, hs) {
  const k = r.toFixed(3) + '_' + ws;
  if (!_geoCache[k]) _geoCache[k] = new THREE.SphereGeometry(r, ws, hs);
  return _geoCache[k];
}
const _matCache = {};
function atomMat(c) {
  if (!_matCache[c]) _matCache[c] = new THREE.MeshStandardMaterial({ color:c, roughness:.38, metalness:.06 });
  return _matCache[c];
}
const BOND_MAT     = new THREE.MeshStandardMaterial({ color:0x555566, roughness:.55 });
const DBL_BOND_MAT = new THREE.MeshStandardMaterial({ color:0xddaa22, roughness:.40, metalness:.04 });
const BOND_R   = 0.10;

// â”€â”€â”€ Double-bond cylinder helper  (two parallel thin cylinders, golden) â”€â”€â”€â”€â”€â”€
function addDoubleBond(p1, p2, group) {
  const dir  = new THREE.Vector3().subVectors(p2, p1).normalize();
  const ref  = Math.abs(dir.y) < 0.9 ? new THREE.Vector3(0,1,0) : new THREE.Vector3(1,0,0);
  const perp = new THREE.Vector3().crossVectors(dir, ref).normalize();
  const sep  = 0.085;   // half-separation in Ã…
  const r    = BOND_R * 0.60;
  [-sep, sep].forEach(s => {
    const s1 = p1.clone().addScaledVector(perp, s);
    const s2 = p2.clone().addScaledVector(perp, s);
    const len = s1.distanceTo(s2);
    if (len < 0.001) return;
    const geo  = new THREE.CylinderGeometry(r, r, len, getCylSegs(), 1);
    const mesh = new THREE.Mesh(geo, DBL_BOND_MAT);
    mesh.userData.disposeCyl = true;
    mesh.position.copy(new THREE.Vector3().addVectors(s1, s2).multiplyScalar(.5));
    mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir.clone());
    group.add(mesh);
  });
}

// â”€â”€â”€ Sphere helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function addSphere(elem, pos, group, overrideColor) {
  const e   = ELEM[elem] || ELEM.C;
  const col = (overrideColor !== undefined) ? overrideColor : e.color;
  const [ws, hs] = getSphereSegs();
  const m   = new THREE.Mesh(sphereGeo(e.r, ws, hs), atomMat(col));
  m.position.copy(pos);
  group.add(m);
}

// â”€â”€â”€ Bond cylinder helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function addBond(p1, p2, group, radius) {
  radius = radius || BOND_R;
  const dir = new THREE.Vector3().subVectors(p2, p1);
  const len = dir.length();
  if (len < 0.001) return;
  const geo  = new THREE.CylinderGeometry(radius, radius, len, getCylSegs(), 1);
  const mesh = new THREE.Mesh(geo, BOND_MAT);
  mesh.userData.disposeCyl = true;
  mesh.position.copy(new THREE.Vector3().addVectors(p1, p2).multiplyScalar(.5));
  mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir.normalize());
  group.add(mesh);
}
function disposeGroup(grp) {
  grp.traverse(o => { if (o.isMesh && o.userData.disposeCyl && o.geometry) o.geometry.dispose(); });
}

// â”€â”€â”€ Seeded pseudo-random â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function srand(seed) {
  const x = Math.sin(seed * 127.1 + 311.7) * 43758.5453;
  return x - Math.floor(x);
}

// â”€â”€â”€ Amorphous dihedral factory  (~55 % T, 22.5 % G+, 22.5 % G-) â”€â”€â”€
function amorFn(seed) {
  return i => { const r = srand(i + seed); return r < .55 ? T : r < .775 ? Gp : Gm; };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  NERF â€” Natural Extension Reference Frame
//  phi_IUPAC = 180Â° â†’ trans | 60Â° â†’ gauche+ | 0Â° â†’ cis/eclipsed
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function nerf(a, b, c, bondLen, bondAngle, phi_IUPAC) {
  const bc = new THREE.Vector3().subVectors(c, b).normalize();
  const ba = new THREE.Vector3().subVectors(b, a).normalize();
  const n1 = new THREE.Vector3().crossVectors(ba, bc).normalize();
  const n2 = new THREE.Vector3().crossVectors(bc, n1);
  const phi = phi_IUPAC - Math.PI;
  const cosA = Math.cos(bondAngle), sinA = Math.sin(bondAngle);
  return new THREE.Vector3().addVectors(c,
    new THREE.Vector3()
      .addScaledVector(bc, -cosA)
      .addScaledVector(n2,  sinA * Math.cos(phi))
      .addScaledVector(n1,  sinA * Math.sin(phi))
      .multiplyScalar(bondLen)
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TETRAHEDRAL SIDE-GROUP GEOMETRY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function sideGroupDirs(c, prev, next) {
  const v1  = new THREE.Vector3().subVectors(prev, c).normalize();
  const v2  = new THREE.Vector3().subVectors(next, c).normalize();
  const sum = new THREE.Vector3().addVectors(v1, v2);
  const m   = sum.length() > 1e-4 ? sum.clone().normalize().negate() : new THREE.Vector3(0,1,0);
  let k = new THREE.Vector3().crossVectors(v1, v2);
  if (k.length() < 1e-4) {
    const ref = Math.abs(m.x) < .9 ? new THREE.Vector3(1,0,0) : new THREE.Vector3(0,1,0);
    k.crossVectors(m, ref);
  }
  k.normalize();
  const v1m = v1.dot(m);
  let cosA = (Math.abs(v1m) > 1e-4) ? (-1/3) / v1m : 0;
  cosA = Math.max(-1, Math.min(1, cosA));
  const sinA = Math.sqrt(Math.max(0, 1 - cosA*cosA));
  return [
    m.clone().multiplyScalar(cosA).addScaledVector(k,  sinA),
    m.clone().multiplyScalar(cosA).addScaledVector(k, -sinA),
  ];
}

function terminalDirs(c, neighbor) {
  const bond = new THREE.Vector3().subVectors(neighbor, c).normalize();
  const ref  = Math.abs(bond.x) < .9 ? new THREE.Vector3(1,0,0) : new THREE.Vector3(0,1,0);
  const p1   = new THREE.Vector3().crossVectors(bond, ref).normalize();
  const p2   = new THREE.Vector3().crossVectors(bond, p1).normalize();
  const cosA = -1/3, sinA = Math.sqrt(1 - cosA*cosA);
  return [0,1,2].map(i => {
    const ang = i * (2*Math.PI/3);
    return new THREE.Vector3()
      .addScaledVector(bond.clone().negate(), cosA)
      .addScaledVector(p1, sinA*Math.cos(ang))
      .addScaledVector(p2, sinA*Math.sin(ang));
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PHENYL RING BUILDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildPhenyl(methPos, ipsoPos, bbTangent, atomGrp, hGrp, bondGrp, showH, merColor) {
  const L    = 1.40;
  const dirI = new THREE.Vector3().subVectors(ipsoPos, methPos).normalize();
  let n = new THREE.Vector3().crossVectors(dirI, bbTangent).normalize();
  if (n.length() < 0.1) n = new THREE.Vector3().crossVectors(dirI, new THREE.Vector3(0,1,0)).normalize();
  const e2     = new THREE.Vector3().crossVectors(n, dirI).normalize();
  const center = ipsoPos.clone().addScaledVector(e2, L);
  const ring   = [];
  for (let i = 0; i < 6; i++) {
    const theta = (270 + i*60) * DEG;
    const p = center.clone()
      .addScaledVector(dirI, L*Math.cos(theta))
      .addScaledVector(e2,   L*Math.sin(theta));
    ring.push(p);
    addSphere('C', p, atomGrp, merColor);
  }
  // KekulÃ©: bonds 0-1, 2-3, 4-5 are double; 1-2, 3-4, 5-0 are single
  for (let i = 0; i < 6; i++) {
    if (i % 2 === 0) addDoubleBond(ring[i], ring[(i+1)%6], bondGrp);
    else             addBond(ring[i], ring[(i+1)%6], bondGrp);
  }
  addBond(methPos, ring[0], bondGrp);
  if (showH) {
    for (let i = 1; i < 6; i++) {
      const dir  = ring[i].clone().sub(center).normalize();
      const hPos = ring[i].clone().addScaledVector(dir, 1.08);
      addSphere('H', hPos, hGrp);
      addBond(ring[i], hPos, hGrp, BOND_R*.7);
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  POLYMER DEFINITIONS
//
//  backbone[i].side codes:
//    'HH'    â€” methylene CHâ‚‚  (2 H)
//    'HMe'   â€” methine  CH(CHâ‚ƒ)  (methyl on dir1, H on dir2)
//    'HCl'   â€” atactic CHCl  (Cl or H randomly on dir1)
//    'HPh'   â€” methine  CH(Ph)   (phenyl on dir1, H on dir2)
//    'MeEst' â€” PMMA quaternary C(CHâ‚ƒ)(COOMe): methyl dir1, ester Câ†’O dir2
//    'FF'    â€” difluoromethylene CFâ‚‚
//    'Me'    â€” sp2 =C(CHâ‚ƒ): methyl on dir1, nothing on dir2  (polyisoprene)
//    'H1'    â€” sp2 =CH:    single H on dir1                  (polyisoprene)
//    'HN'    â€” backbone N: single N-H on dir1
//    'C=O'   â€” backbone C=O: carbonyl O on dir1 (1.22 Ã…)
//    'MeMe'  â€” PDMS Si(CHâ‚ƒ)â‚‚: methyls on both dir1 and dir2
//    'PhBB'  â€” para-phenylene ring bridging backbone atom i (Câ‚/ipso) and i+1 (Câ‚„/para)
//    'HEMASide' â€” pHEMA C(CHâ‚ƒ)(COOCHâ‚‚CHâ‚‚OH) quaternary: methyl dir1, hydroxyethyl ester dir2
//    ''      â€” no side groups (backbone O, ester O, etc.)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const POLYMERS = {

  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  //  ADDITION POLYMERS
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  PE: {
    name: 'Polyethylene', cat: 'addition',
    formula: 'â€”(CHâ‚‚â€”CHâ‚‚)â‚™â€”',
    synth: 'Free-radical (LDPE) / Ziegler-Natta or metallocene (HDPE)',
    ba: '112Â°',
    badge:   { crystal:'PE Â· All-trans planar zigzag', amorphous:'PE Â· Amorphous random coil' },
    conf:    { crystal:'All-trans planar zigzag', amorphous:'Random coil (T / GÂ± mixture)' },
    backbone: [
      { elem:'C', bl:1.54, ba:112*DEG, side:'HH' },
      { elem:'C', bl:1.54, ba:112*DEG, side:'HH' },
    ],
    dihedralFn:  () => T,
    amorphousFn: amorFn(7),
    info: {
      crystal:   { Tg:'~âˆ’120 Â°C', Tm:'~137 Â°C (HDPE) / 115 Â°C (LDPE)', density:'1.00 g/cmÂ³ (xtal)',
        desc:'The simplest polymer: a pure carbon backbone with two hydrogens at every carbon. In the crystal, all backbone dihedrals are trans (180Â°), giving the perfectly flat planar zigzag â€” the textbook reference conformation. HDPE (high-density PE) is ~70â€“90 % crystalline with few branches; LDPE has many short branches that disrupt packing. PE is the world\'s highest-volume plastic.' },
      amorphous: { Tg:'~âˆ’120 Â°C', Tm:'â€” (amorphous / melt)', density:'0.85 g/cmÂ³',
        desc:'The amorphous fraction of PE is rubbery far above its Tg (âˆ’120 Â°C), contributing toughness and flexibility. In LDPE, the high branch content keeps crystallinity low (~40â€“50 %), giving a soft, flexible film material (bread bags, cling film). Compare with HDPE or the crystal mode to see how conformation drives density.' },
    },
  },

  aPP: {
    name: 'Atactic Polypropylene', cat: 'addition',
    formula: 'â€”(CHâ‚‚â€”CHR)â‚™â€” Â· R = CHâ‚ƒ',
    synth: 'Free-radical / Ziegler-Natta',
    ba: '112Â°',
    badge:   { crystal:'aPP Â· All-trans planar zigzag', amorphous:'aPP Â· Amorphous random coil' },
    conf:    { crystal:'All-trans planar zigzag', amorphous:'Random coil (T / GÂ± mixture)' },
    backbone: [
      { elem:'C', bl:1.54, ba:112*DEG, side:'HH'  },
      { elem:'C', bl:1.54, ba:112*DEG, side:'HMe' },
    ],
    dihedralFn:  i => { const r=srand(i+71); return r<.60?T:r<.82?Gp:Gm; },
    amorphousFn: amorFn(73),
    info: {
      crystal:   { Tg:'~âˆ’10 Â°C', Tm:'â€” (amorphous)', density:'0.85 g/cmÂ³',
        desc:'The all-trans planar zigzag shows the most extended conformation of the PP backbone. Atactic PP cannot actually crystallise (random methyl chirality prevents packing), but this view lets you compare the fully extended chain with the random coil. Atactic PP is a soft, rubbery material used as an additive.' },
      amorphous: { Tg:'~âˆ’10 Â°C', Tm:'â€” (amorphous)', density:'0.85 g/cmÂ³',
        desc:'The fully random coil shows gauche-plus and gauche-minus defects distributed stochastically. Compare with iPP (crystal) to see how stereoregularity enables helix formation.' },
    },
  },

  iPP: {
    name: 'Isotactic Polypropylene', cat: 'addition',
    formula: 'â€”(CHâ‚‚â€”CH(CHâ‚ƒ))â‚™â€”',
    synth: 'Ziegler-Natta / metallocene',
    ba: '112Â°',
    badge:   { crystal:'iPP Â· All-trans planar zigzag', amorphous:'iPP Â· Amorphous random coil' },
    conf:    { crystal:'All-trans planar zigzag', amorphous:'Random coil (T / GÂ± mixture)' },
    backbone: [
      { elem:'C', bl:1.54, ba:112*DEG, side:'HH'  },
      { elem:'C', bl:1.54, ba:112*DEG, side:'HMe' },
    ],
    dihedralFn:  i => (i%2===0) ? T : Gp,
    amorphousFn: amorFn(11),
    info: {
      crystal:   { Tg:'~0 Â°C', Tm:'~165 Â°C', density:'0.946 g/cmÂ³ (xtal)',
        desc:'All-trans backbone showing the fully extended planar zigzag. In reality iPP crystallises as a 3â‚ helix (TGâº)â‚™ â€” switch to amorphous to see random conformations. Made with Ziegler-Natta catalysts (Natta Nobel Prize 1963). Compare methyl positions with aPP to see how isotactic regularity differs.' },
      amorphous: { Tg:'~0 Â°C', Tm:'â€” (amorphous phase)', density:'~0.85 g/cmÂ³',
        desc:'Without helical order the methyl groups point randomly. About 50 % of semi-crystalline iPP is amorphous, contributing to toughness.' },
    },
  },

  aPS: {
    name: 'Atactic Polystyrene', cat: 'addition',
    formula: 'â€”(CHâ‚‚â€”CH(Ph))â‚™â€”',
    synth: 'Free-radical polymerisation',
    ba: '112Â°',
    badge:   { crystal:'aPS Â· All-trans planar zigzag', amorphous:'aPS Â· Amorphous random coil' },
    conf:    { crystal:'All-trans planar zigzag', amorphous:'Random coil (T / GÂ± mixture)' },
    backbone: [
      { elem:'C', bl:1.54, ba:112*DEG, side:'HH'  },
      { elem:'C', bl:1.54, ba:112*DEG, side:'HPh' },
    ],
    dihedralFn:  i => { const r=srand(i+79); return r<.55?T:r<.775?Gp:Gm; },
    amorphousFn: amorFn(83),
    info: {
      crystal:   { Tg:'~100 Â°C', Tm:'â€” (amorphous)', density:'1.04 g/cmÂ³',
        desc:'All-trans backbone showing the fully extended planar zigzag. Atactic PS cannot crystallise (random phenyl chirality). This view lets you see the pendant phenyl groups clearly along the extended chain. Common PS is atactic â€” used in foam cups, CD jewel cases, disposable cutlery.' },
      amorphous: { Tg:'~100 Â°C', Tm:'â€” (amorphous)', density:'1.04 g/cmÂ³',
        desc:'Fully random coil with random phenyl orientations. Tg â‰ˆ 100 Â°C â€” above this temperature PS flows; below it is a rigid glass. This is the standard form of commercial PS.' },
    },
  },

  iPS: {
    name: 'Isotactic Polystyrene', cat: 'addition',
    formula: 'â€”(CHâ‚‚â€”CH(Ph))â‚™â€”',
    synth: 'Ziegler-Natta / anionic',
    ba: '112Â°',
    badge:   { crystal:'iPS Â· All-trans planar zigzag + phenyl', amorphous:'iPS Â· Amorphous random coil' },
    conf:    { crystal:'All-trans planar zigzag', amorphous:'Random coil (T / GÂ± mixture)' },
    backbone: [
      { elem:'C', bl:1.54, ba:112*DEG, side:'HH'  },
      { elem:'C', bl:1.54, ba:112*DEG, side:'HPh' },
    ],
    dihedralFn:  i => (i%2===0) ? T : Gp,
    amorphousFn: amorFn(37),
    info: {
      crystal:   { Tg:'~100 Â°C', Tm:'~240 Â°C (iPS)', density:'1.10 g/cmÂ³',
        desc:'All-trans backbone with all phenyl groups visible along the extended chain. In reality, iPS crystallises as a 3â‚ helix (TGâº)â‚™. The isotactic stereoregularity means all phenyls lie on the same side of the backbone â€” compare with atactic PS to see the difference.' },
      amorphous: { Tg:'~100 Â°C', Tm:'â€” (amorphous)', density:'~1.04 g/cmÂ³',
        desc:'Without helical order the phenyls point randomly. The high Tg of ~100 Â°C reflects restricted local chain motion due to the bulky aromatic side groups.' },
    },
  },

  PVC: {
    name: 'Poly(vinyl chloride)', cat: 'addition',
    formula: 'â€”(CHâ‚‚â€”CHCl)â‚™â€”',
    synth: 'Free-radical polymerisation',
    ba: '112Â°',
    badge:   { crystal:'PVC Â· All-trans planar zigzag', amorphous:'PVC Â· Amorphous â€” disordered' },
    conf:    { crystal:'All-trans planar zigzag', amorphous:'Disordered atactic chain' },
    backbone: [
      { elem:'C', bl:1.54, ba:112*DEG, side:'HH'  },
      { elem:'C', bl:1.54, ba:112*DEG, side:'HCl' },
    ],
    dihedralFn:  i => { const r=srand(i+17); return r<.60?T:r<.82?Gp:Gm; },
    amorphousFn: i => { const r=srand(i+43); return r<.38?T:r<.69?Gp:Gm; },
    info: {
      crystal:   { Tg:'~82 Â°C', Tm:'â€” (no clean Tm)', density:'1.39 g/cmÂ³',
        desc:'All-trans backbone: the most extended conformation possible. Atactic PVC cannot crystallise (random Cl chirality), but this view clearly shows the alternating Cl positions along the zigzag. The large Cl atom raises Tg well above room temperature, making rigid PVC hard and strong.' },
      amorphous: { Tg:'~82 Â°C', Tm:'â€” (amorphous)', density:'~1.38 g/cmÂ³',
        desc:'Gauche conformers dominate and the chain coils. Plasticisers (e.g., DEHP) intercalate between chains to lower Tg for flexible PVC applications (tubing, wire insulation, flooring).' },
    },
  },

  PMMA: {
    name: 'Poly(methyl methacrylate)', cat: 'addition',
    formula: 'â€”(CHâ‚‚â€”C(CHâ‚ƒ)(COOMe))â‚™â€”',
    synth: 'Free-radical polymerisation',
    ba: '112Â°',
    badge:   { crystal:'PMMA Â· All-trans planar zigzag', amorphous:'PMMA Â· Amorphous random coil' },
    conf:    { crystal:'All-trans planar zigzag', amorphous:'Random coil (T / GÂ± mixture)' },
    backbone: [
      { elem:'C', bl:1.54, ba:112*DEG, side:'HH'    },   // CHâ‚‚
      { elem:'C', bl:1.54, ba:112*DEG, side:'MeEst' },   // C(CHâ‚ƒ)(COOMe) â€” quaternary
    ],
    dihedralFn:  i => { const r=srand(i+89); return r<.55?T:r<.775?Gp:Gm; },
    amorphousFn: amorFn(97),
    info: {
      crystal:   { Tg:'~105 Â°C', Tm:'â€” (amorphous)', density:'1.18 g/cmÂ³',
        desc:'All-trans backbone showing the quaternary carbon (no H on backbone) clearly: each repeat bears one methyl and one ester group (-COOMe). Atactic PMMA (Plexiglas / Perspex) cannot crystallise. This extended view best illustrates the bulky ester side chain geometry.' },
      amorphous: { Tg:'~105 Â°C', Tm:'â€” (amorphous)', density:'~1.17 g/cmÂ³',
        desc:'Fully random coil. PMMA is optically transparent (visible-light wavelengths exceed its feature size), impact resistant, and used for lenses, aquariums, aircraft windows, and dental prosthetics.' },
    },
  },

  PTFE: {
    name: 'Polytetrafluoroethylene (PTFE)', cat: 'addition',
    formula: 'â€”(CFâ‚‚â€”CFâ‚‚)â‚™â€”',
    synth: 'Free-radical polymerisation',
    ba: '112Â°',
    badge:   { crystal:'PTFE Â· All-trans planar zigzag (CFâ‚‚)', amorphous:'PTFE Â· Amorphous near-trans random' },
    conf:    { crystal:'All-trans planar zigzag', amorphous:'Random near-trans coil' },
    backbone: [
      { elem:'C', bl:1.54, ba:112*DEG, side:'FF' },
      { elem:'C', bl:1.54, ba:112*DEG, side:'FF' },
    ],
    dihedralFn:  i => (i%2===0) ? 165*DEG : -165*DEG,
    amorphousFn: amorFn(53),
    info: {
      crystal:   { Tg:'âˆ’113 Â°C', Tm:'~327 Â°C', density:'2.20 g/cmÂ³',
        desc:'All-trans zigzag clearly shows the CFâ‚‚ repeat: both fluorines pointing out on each side of the backbone. In reality PTFE crystallises as a 13â‚† helix (Â±165Â° dihedrals) because large F atoms force slight deviations from 180Â°. The F sheath gives PTFE (TeflonÂ®) exceptional chemical inertness and the lowest kinetic friction among solids.' },
      amorphous: { Tg:'âˆ’113 Â°C', Tm:'â€” (melt)', density:'~2.0 g/cmÂ³',
        desc:'Above Tm PTFE loses its regular twist. Large F atoms still strongly favour near-trans conformations, so melt viscosity is extremely high and PTFE cannot be conventionally melt-processed.' },
    },
  },

  PI: {
    name: 'cis-1,4-Polyisoprene (Natural Rubber)', cat: 'addition',
    formula: 'â€”(CHâ‚‚â€”C(CHâ‚ƒ)=CHâ€”CHâ‚‚)â‚™â€”',
    synth: 'Free-radical / Ziegler-Natta Â· also biosynthetic',
    ba: '112Â° (spÂ³) / 120Â° (spÂ²)',
    keepCrystalConf: true,   // must keep cis C=C (phi=0Â°); single bonds already trans
    badge:   { crystal:'PI Â· cis-1,4 extended â€” cis C=C, trans single bonds', amorphous:'PI Â· Amorphous rubber' },
    conf:    { crystal:'cis C=C Â· all-trans single bonds (most extended)', amorphous:'cis C=C Â· random single-bond dihedrals' },
    // 4 backbone atoms per mer: CHâ‚‚ â€“ C(CHâ‚ƒ)= â€“ =CHâ€“ â€“ CHâ‚‚
    backbone: [
      { elem:'C', bl:1.54, ba:112*DEG, side:'HH' },   // allylic CHâ‚‚
      { elem:'C', bl:1.54, ba:120*DEG, side:'Me' },   // =C(CHâ‚ƒ)â€“ sp2, methyl only
      { elem:'C', bl:1.34, ba:120*DEG, side:'H1', doubleBondHere:true },   // =CHâ€“  sp2, C=C double bond
      { elem:'C', bl:1.54, ba:112*DEG, side:'HH' },   // allylic CHâ‚‚
    ],
    // cis-1,4: C=C dihedral = 0Â° (syn/cis), single bonds = trans
    dihedralFn: i => {
      const atom = (i + 3) % 4;
      if (atom === 2) return 0;   // C=C: phi_IUPAC = 0Â° â†’ cis configuration
      return T;                    // single bonds: trans
    },
    amorphousFn: i => {
      const atom = (i + 3) % 4;
      if (atom === 2) return 0;           // C=C always cis
      const r = srand(i + 103); return r < .55 ? T : r < .775 ? Gp : Gm;
    },
    info: {
      crystal:   { Tg:'~âˆ’73 Â°C', Tm:'~36 Â°C', density:'1.00 g/cmÂ³ (xtal)',
        desc:'Natural rubber: cis configuration at every C=C fixes the CHâ‚‚ groups on the same side. In the crystal, single-bond dihedrals are trans, giving an extended helical structure. The cis constraint prevents the close packing possible in trans-1,4 (gutta-percha), giving a lower Tm.' },
      amorphous: { Tg:'~âˆ’73 Â°C', Tm:'â€” (amorphous rubber)', density:'0.91 g/cmÂ³',
        desc:'Above Tg the single bonds rotate freely while cis configuration is maintained. The result is a highly flexible random coil â€” the basis of rubber elasticity. Under strain the chains extend and can crystallise (strain-induced crystallisation), reinforcing the rubber.' },
    },
  },

  pHEMA: {
    name: 'Poly(2-hydroxyethyl methacrylate)', cat: 'addition',
    formula: 'â€”(CHâ‚‚â€”C(CHâ‚ƒ)(COOCHâ‚‚CHâ‚‚OH))â‚™â€”',
    synth: 'Free-radical polymerisation',
    ba: '112Â°',
    badge:   { crystal:'pHEMA Â· All-trans planar zigzag', amorphous:'pHEMA Â· Amorphous hydrogel network' },
    conf:    { crystal:'All-trans planar zigzag', amorphous:'Random coil (T / GÂ± mixture)' },
    backbone: [
      { elem:'C', bl:1.54, ba:112*DEG, side:'HH'       },   // CHâ‚‚ methylene
      { elem:'C', bl:1.54, ba:112*DEG, side:'HEMASide' },   // C(CHâ‚ƒ)(COOCHâ‚‚CHâ‚‚OH) quaternary
    ],
    dihedralFn:  i => { const r=srand(i+157); return r<.55?T:r<.775?Gp:Gm; },
    amorphousFn: amorFn(163),
    info: {
      crystal:   { Tg:'~55 Â°C', Tm:'â€” (amorphous)', density:'1.27 g/cmÂ³',
        desc:'All-trans backbone clearly shows the quaternary carbon repeat unit: each mer bears one methyl and one hydroxyethyl ester group (â€“COOCHâ‚‚CHâ‚‚OH). pHEMA is atactic and cannot crystallise, but the extended view illustrates the side-chain geometry. The pendant â€“OH terminus is responsible for the material\'s hydrophilicity and biocompatibility.' },
      amorphous: { Tg:'~55 Â°C', Tm:'â€” (hydrogel)', density:'~1.20 g/cmÂ³',
        desc:'Cross-linked pHEMA absorbs ~38 wt% water to form a soft, compliant hydrogel. The pendant â€“OH groups hydrogen-bond with water, maintaining a moist, protein-resistant surface. Invented by Wichterle & LÃ­m (1960) â€” pHEMA hydrogel was the first practical soft contact lens material. Also used in wound dressings, drug-delivery matrices, and tissue engineering scaffolds.' },
    },
  },

  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
  //  CONDENSATION / STEP-GROWTH POLYMERS
  // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  iPLA: {
    name: 'Isotactic Poly(lactic acid) â€” PLLA', cat: 'condensation',
    formula: 'â€”(CH(CHâ‚ƒ)â€”COâ€”O)â‚™â€”',
    synth: 'Ring-opening polymerisation of L-lactide',
    ba: '112Â° (spÂ³) / 116Â° (ester)',
    badge:   { crystal:'iPLA Â· All-trans planar zigzag', amorphous:'iPLA Â· Amorphous random coil' },
    conf:    { crystal:'All-trans planar zigzag', amorphous:'Random coil (T / GÂ± mixture)' },
    // 3 backbone atoms per mer: C(methine) â€“ C(carbonyl) â€“ O(ester)
    backbone: [
      { elem:'C', bl:1.44, ba:112*DEG, side:'HMe' },   // CH(CHâ‚ƒ) methine; bl = Oâ†’C bond
      { elem:'C', bl:1.52, ba:116*DEG, side:'C=O' },   // C(=O) carbonyl;  bl = Câ€“C bond
      { elem:'O', bl:1.33, ba:116*DEG, side:''    },   // O ester;          bl = C=Oâ†’O bond
    ],
    // Approximate 10â‚ƒ helix dihedrals (T, Gâº, T per 3-bond repeat)
    dihedralFn:  i => [T, Gp, T][i % 3],
    amorphousFn: amorFn(61),
    info: {
      crystal:   { Tg:'~55 Â°C', Tm:'~175 Â°C (PLLA)', density:'1.29 g/cmÂ³ (xtal)',
        desc:'All-trans backbone clearly shows the 3-atom repeat unit: methine CH(CHâ‚ƒ) â€” carbonyl C=O â€” ester O, cycling along the zigzag. Made by ring-opening polymerisation of L-lactide (renewable: from corn starch). The ester backbone allows hydrolytic degradation, making PLA biocompatible for sutures, packaging, and 3D-printing filament.' },
      amorphous: { Tg:'~55 Â°C', Tm:'â€” (amorphous)', density:'1.24 g/cmÂ³',
        desc:'Amorphous PLA is glassy below Tg (~55 Â°C). Used in clear food packaging, 3D printing (FDM filament), and drug-delivery matrices. Faster degradation than crystalline PLLA due to greater water accessibility.' },
    },
  },

  Nylon66: {
    name: 'Nylon 6,6 (polyamide)', cat: 'condensation',
    formula: 'â€”[NH(CHâ‚‚)â‚†NHÂ·CO(CHâ‚‚)â‚„CO]â‚™â€”',
    synth: 'Condensation of hexamethylenediamine + adipic acid',
    ba: '112Â° (CHâ‚‚) / 121Â° (amide N)',
    badge:   { crystal:'Nylon 6,6 Â· All-trans planar zigzag', amorphous:'Nylon 6,6 Â· Amorphous random coil' },
    conf:    { crystal:'All-trans planar zigzag (H-bonded sheets)', amorphous:'Random coil' },
    // 14 backbone atoms per mer: N,C,C,C,C,C,C,N,C,C,C,C,C,C
    // N at pos 0 and 7; C=O at pos 8 and 13 (simplified: just show O side group)
    backbone: [
      { elem:'N', bl:1.46, ba:121*DEG, side:'HN'  },   // NH (hexamethylene diamine end)
      { elem:'C', bl:1.53, ba:112*DEG, side:'HH'  },
      { elem:'C', bl:1.54, ba:112*DEG, side:'HH'  },
      { elem:'C', bl:1.54, ba:112*DEG, side:'HH'  },
      { elem:'C', bl:1.54, ba:112*DEG, side:'HH'  },
      { elem:'C', bl:1.54, ba:112*DEG, side:'HH'  },
      { elem:'C', bl:1.54, ba:112*DEG, side:'HH'  },
      { elem:'N', bl:1.46, ba:121*DEG, side:'HN'  },   // NH (second amine)
      { elem:'C', bl:1.52, ba:116*DEG, side:'C=O' },   // C=O (adipoyl carbonyl 1)
      { elem:'C', bl:1.54, ba:112*DEG, side:'HH'  },
      { elem:'C', bl:1.54, ba:112*DEG, side:'HH'  },
      { elem:'C', bl:1.54, ba:112*DEG, side:'HH'  },
      { elem:'C', bl:1.54, ba:112*DEG, side:'HH'  },
      { elem:'C', bl:1.52, ba:116*DEG, side:'C=O' },   // C=O (adipoyl carbonyl 2)
    ],
    dihedralFn:  () => T,
    amorphousFn: amorFn(113),
    info: {
      crystal:   { Tg:'~50 Â°C', Tm:'~265 Â°C', density:'1.24 g/cmÂ³ (xtal)',
        desc:'Nylon 6,6 crystals consist of all-trans chains in hydrogen-bonded sheets. The Nâ€“HÂ·Â·Â·O=C hydrogen bonds (2.86 Ã…) between adjacent chains provide exceptional strength and Tm (~265 Â°C). Condensation of hexamethylenediamine + adipic acid, discovered by Wallace Carothers (DuPont, 1935).' },
      amorphous: { Tg:'~50 Â°C', Tm:'â€” (amorphous phase)', density:'1.07 g/cmÂ³',
        desc:'The amorphous fraction absorbs water at Nâ€“H groups (moisture uptake ~8 wt%), reducing Tg and modulus. Used as engineering plastic for gears, bearings, toothbrush bristles, and tyre cord.' },
    },
  },

  PDMS: {
    name: 'Poly(dimethylsiloxane)', cat: 'condensation',
    formula: 'â€”(Si(CHâ‚ƒ)â‚‚â€”O)â‚™â€”',
    synth: 'Ring-opening (cyclic siloxanes) or condensation',
    ba: '110Â° (Oâ€“Siâ€“O) / 142Â° (Siâ€“Oâ€“Si)',
    keepCrystalConf: true,   // all-trans would curl into a circle (108Â° bend/mer); keep 4â‚ helix
    badge:   { crystal:'PDMS Â· 4â‚ helix (all-gaucheâº Siâ€“O)', amorphous:'PDMS Â· Amorphous random coil' },
    conf:    { crystal:'4â‚ helix â€” 4 Siâ€“O units per turn (all-gaucheâº)', amorphous:'Random coil (very flexible)' },
    // 2 backbone atoms per mer: Si â€“ O
    // ba at Si used to place O: Oâ€“Siâ€“O = 110Â°; ba at O used to place next Si: Siâ€“Oâ€“Si = 142Â°
    backbone: [
      { elem:'Si', bl:1.64, ba:110*DEG, side:'MeMe' },   // Si(CHâ‚ƒ)â‚‚
      { elem:'O',  bl:1.64, ba:142*DEG, side:''     },   // bridging O
    ],
    dihedralFn:  () => Gp,     // 4â‚ helix: all-gaucheâº gives 4 repeat units per turn
    amorphousFn: amorFn(121),
    info: {
      crystal:   { Tg:'~âˆ’127 Â°C', Tm:'~âˆ’40 Â°C', density:'1.10 g/cmÂ³',
        desc:'PDMS crystal adopts a 4â‚ helix (all-gaucheâº): four Siâ€“O repeat units per full turn. The extremely wide Siâ€“Oâ€“Si angle (142Â°) means an all-trans chain would curl back on itself; the gauche conformation extends the chain helically instead. Note the golden Si atoms with their two methyl groups and the alternating Siâ€“O bond lengths. PDMS has one of the most flexible backbones known â€” very low barrier to Siâ€“O bond rotation.' },
      amorphous: { Tg:'~âˆ’127 Â°C', Tm:'â€” (rubbery at RT)', density:'0.97 g/cmÂ³',
        desc:'At room temperature PDMS is far above Tg, giving a highly flexible elastomer. Used as silicone rubber, microfluidic devices (PDMS soft lithography), medical implants, cookware coatings, and heat-transfer fluids. Biocompatible and optically transparent.' },
    },
  },

  PET: {
    name: 'Poly(ethylene terephthalate)', cat: 'condensation',
    formula: 'â€”[OCHâ‚‚CHâ‚‚OC(=O)â€”Phâ€”C(=O)]â‚™â€”',
    synth: 'Condensation of ethylene glycol + terephthalic acid',
    ba: '112Â° (CHâ‚‚) / 116Â° (ester O) / 120Â° (aromatic/carbonyl)',
    badge:   { crystal:'PET Â· All-trans planar zigzag (para-phenylene ester)', amorphous:'PET Â· Amorphous random coil' },
    conf:    { crystal:'All-trans planar zigzag', amorphous:'Random coil (T / GÂ± mixture)' },
    // 8 backbone atoms per mer:
    // O(ester-glycol) â€“ CHâ‚‚ â€“ CHâ‚‚ â€“ O(ester-acid) â€“ C(=O) â€“ Câ‚(ring) â€“ Câ‚„(ring, skipBond) â€“ C(=O)
    backbone: [
      { elem:'O', bl:1.33, ba:116*DEG, side:''    },          // ester O (glycol side)
      { elem:'C', bl:1.44, ba:112*DEG, side:'HH'  },          // CHâ‚‚
      { elem:'C', bl:1.54, ba:112*DEG, side:'HH'  },          // CHâ‚‚
      { elem:'O', bl:1.44, ba:116*DEG, side:''    },          // ester O (acid side)
      { elem:'C', bl:1.33, ba:120*DEG, side:'C=O' },          // C(=O) carbonyl
      { elem:'C', bl:1.48, ba:120*DEG, side:'PhBB'},          // Câ‚ ipso (ring A)
      { elem:'C', bl:2.80, ba:120*DEG, side:'', skipBond:true }, // Câ‚„ para (ring bridges here)
      { elem:'C', bl:1.48, ba:120*DEG, side:'C=O' },          // C(=O) other carbonyl
    ],
    dihedralFn:  () => T,
    amorphousFn: amorFn(131),
    info: {
      crystal:   { Tg:'~80 Â°C', Tm:'~260 Â°C', density:'1.46 g/cmÂ³ (xtal)',
        desc:'PET crystal is an all-trans planar chain: the para-phenylene ring lies flat in the backbone plane, connected by ester linkages to the ethylene glycol â€“OCHâ‚‚CHâ‚‚Oâ€“ segments. The golden double-bond cylinders on each carbonyl and the hexagonal ring are clearly visible. PET is the most widely produced polyester â€” beverage bottles (#1 recyclable) and textile fibres (DacronÂ®, TeryleneÂ®). Made by condensation of ethylene glycol + terephthalic acid, releasing water.' },
      amorphous: { Tg:'~80 Â°C', Tm:'â€” (amorphous)', density:'1.33 g/cmÂ³',
        desc:'Amorphous PET is optically clear and glassy below Tg (~80 Â°C). Stretch blow-moulding induces strain crystallisation, producing the strong transparent bottles used for carbonated drinks. Film-grade amorphous PET is used for packaging and photographic film base.' },
    },
  },

  PEEK: {
    name: 'Poly(ether ether ketone)', cat: 'condensation',
    formula: 'â€”[Phâ€“Oâ€“Phâ€“Oâ€“Phâ€“C(=O)]â‚™â€”',
    synth: 'Step-growth (nucleophilic aromatic substitution)',
    ba: '120Â° (all aromatic)',
    badge:   { crystal:'PEEK Â· All-trans extended chain (3 rings/mer)', amorphous:'PEEK Â· Semi-crystalline amorphous' },
    conf:    { crystal:'All-trans planar zigzag', amorphous:'Random coil' },
    // 9 backbone atoms/mer: 3 para-phenylene rings + 2 ether O + 1 ketone C(=O)
    backbone: [
      { elem:'C', bl:1.48, ba:120*DEG, side:'PhBB'},              // Câ‚A ring A (ipso)
      { elem:'C', bl:2.80, ba:120*DEG, side:'', skipBond:true },  // Câ‚„A (para, no direct bond drawn)
      { elem:'O', bl:1.36, ba:120*DEG, side:''    },              // ether O (1)
      { elem:'C', bl:1.36, ba:120*DEG, side:'PhBB'},              // Câ‚B ring B (ipso)
      { elem:'C', bl:2.80, ba:120*DEG, side:'', skipBond:true },  // Câ‚„B (para)
      { elem:'O', bl:1.36, ba:120*DEG, side:''    },              // ether O (2)
      { elem:'C', bl:1.36, ba:120*DEG, side:'PhBB'},              // Câ‚C ring C (ipso)
      { elem:'C', bl:2.80, ba:120*DEG, side:'', skipBond:true },  // Câ‚„C (para)
      { elem:'C', bl:1.48, ba:120*DEG, side:'C=O' },              // ketone C(=O)
    ],
    dihedralFn:  () => T,
    amorphousFn: amorFn(139),
    info: {
      crystal:   { Tg:'~145 Â°C', Tm:'~343 Â°C', density:'1.40 g/cmÂ³ (xtal)',
        desc:'PEEK crystal is an extended chain with three para-phenylene rings per repeat unit, connected by two ether oxygens and a terminal ketone. The rigid all-aromatic backbone gives PEEK one of the highest Tm values (~343 Â°C) among thermoplastics, plus exceptional chemical and fatigue resistance. Used in aerospace brackets, implantable orthopaedic devices (spinal cages, bone screws â€” radiolucent), and semiconductor equipment.' },
      amorphous: { Tg:'~145 Â°C', Tm:'â€” (amorphous)', density:'~1.30 g/cmÂ³',
        desc:'Amorphous PEEK is glassy and stiff above Tg ~145 Â°C. Typical semi-crystalline PEEK is ~35 % crystalline. The high Tg allows continuous service above 150 Â°C. Compared to titanium for bone implants â€” similar stiffness, radiolucent on X-ray, and biocompatible.' },
    },
  },

  PEO: {
    name: 'Poly(ethylene oxide)', cat: 'condensation',
    formula: 'â€”(CHâ‚‚â€”CHâ‚‚â€”O)â‚™â€”',
    synth: 'Ring-opening polymerisation of ethylene oxide',
    ba: '112Â°',
    badge:   { crystal:'PEO Â· All-trans planar zigzag (Câ€“Câ€“O)', amorphous:'PEO Â· Amorphous random coil' },
    conf:    { crystal:'All-trans planar zigzag', amorphous:'Random coil (T / GÂ± mixture)' },
    backbone: [
      { elem:'C', bl:1.54, ba:112*DEG, side:'HH' },
      { elem:'C', bl:1.54, ba:112*DEG, side:'HH' },
      { elem:'O', bl:1.43, ba:112*DEG, side:''   },
    ],
    dihedralFn:  i => [T, Gp, T][i % 3],
    amorphousFn: amorFn(61),
    info: {
      crystal:   { Tg:'âˆ’67 Â°C', Tm:'~67 Â°C', density:'1.21 g/cmÂ³ (xtal)',
        desc:'All-trans backbone showing the 3-atom repeat unit â€“CHâ‚‚â€“CHâ‚‚â€“Oâ€“ clearly along the zigzag. The ether O appears in red at every third position. PEO is a solid polymer electrolyte host for Liâº in batteries (Liâº coordinates to ether oxygens) and is widely used in drug-delivery PEGylation to extend protein half-lives.' },
      amorphous: { Tg:'âˆ’67 Â°C', Tm:'â€” (amorphous / melt)', density:'~1.12 g/cmÂ³',
        desc:'Amorphous PEO is water-soluble. The ether oxygens form hydrogen bonds with water. Above Tm, the melt conducts Liâº ions efficiently, enabling all-solid-state Li batteries.' },
    },
  },

};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CHAIN BUILDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildChain(key, numMers, showH, colourMers, conformMode) {
  const poly = POLYMERS[key];
  const bk   = poly.backbone;
  const nPM  = bk.length;
  const N    = numMers * nPM;

  // Crystal mode: always all-trans (planar zigzag) for clear, unambiguous structure,
  // UNLESS the polymer sets keepCrystalConf:true (e.g. cis-PI where C=C must stay cis).
  // Amorphous mode: uses the polymer's own amorphousFn (random coil).
  const dfn = (conformMode === 'amorphous' && poly.amorphousFn)
              ? poly.amorphousFn
              : (poly.keepCrystalConf ? poly.dihedralFn : () => T);

  const bbAtomGrp   = new THREE.Group();
  const sideAtomGrp = new THREE.Group();
  const hGrp        = new THREE.Group();
  const bondGrp     = new THREE.Group();
  const bbBondGrp   = new THREE.Group();

  const BL = i => bk[i % nPM].bl;
  const BA = i => bk[i % nPM].ba;

  // â”€â”€ 1. Build backbone with NERF â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const bkPos  = [];
  const bkElem = [];

  bkPos[0]  = new THREE.Vector3(0, 0, 0);
  bkElem[0] = bk[0].elem;

  const bl01 = BL(1);
  bkPos[1]   = new THREE.Vector3(bl01, 0, 0);
  bkElem[1]  = bk[1 % nPM].elem;

  if (N >= 3) {
    const ba1 = BA(1);
    const xC  = -Math.cos(ba1);
    const zC  = Math.sqrt(Math.max(0, 1 - xC*xC));
    bkPos[2]  = new THREE.Vector3(bkPos[1].x + BL(2)*xC, 0, BL(2)*zC);
    bkElem[2] = bk[2 % nPM].elem;
  }

  for (let i = 3; i < N; i++) {
    bkPos[i]  = nerf(bkPos[i-3], bkPos[i-2], bkPos[i-1], BL(i), BA(i-1), dfn(i-3));
    bkElem[i] = bk[i % nPM].elem;
  }

  // Centre on centroid
  const ctr = new THREE.Vector3();
  bkPos.forEach(p => ctr.add(p));
  ctr.divideScalar(N);
  bkPos.forEach(p => p.sub(ctr));

  let extent = 0;
  bkPos.forEach(p => { const d = p.length(); if (d > extent) extent = d; });

  // â”€â”€ 2. Backbone atoms + bonds â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let totalAtoms = 0;
  for (let i = 0; i < N; i++) {
    const merIdx   = Math.floor(i / nPM);
    const merColor = colourMers ? MER_COLORS[merIdx % 2] : undefined;
    addSphere(bkElem[i], bkPos[i], bbAtomGrp, merColor);
    totalAtoms++;
    if (i > 0) {
      const bkDef = bk[i % nPM];
      if (!bkDef.skipBond) {
        if (bkDef.doubleBondHere) {
          addDoubleBond(bkPos[i-1], bkPos[i], bondGrp);
          addDoubleBond(bkPos[i-1], bkPos[i], bbBondGrp);
        } else {
          addBond(bkPos[i-1], bkPos[i], bondGrp);
          addBond(bkPos[i-1], bkPos[i], bbBondGrp);
        }
      }
    }
  }

  // â”€â”€ 3. Side groups â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  for (let i = 0; i < N; i++) {
    const sideDef  = bk[i % nPM].side;
    if (!sideDef) continue;

    // Terminal cap
    if (i === 0 || i === N - 1) {
      if (showH) {
        const nb = (i === 0) ? bkPos[1] : bkPos[N-2];
        terminalDirs(bkPos[i], nb).forEach(d => {
          const hp = bkPos[i].clone().addScaledVector(d, 1.09);
          addSphere('H', hp, hGrp);
          addBond(bkPos[i], hp, hGrp, BOND_R*.7);
          totalAtoms++;
        });
      }
      continue;
    }

    const dirs   = sideGroupDirs(bkPos[i], bkPos[i-1], bkPos[i+1]);
    const dir1   = dirs[0], dir2 = dirs[1];
    const merIdx   = Math.floor(i / nPM);
    const merColor = colourMers ? MER_COLORS[merIdx % 2] : undefined;

    // â”€â”€ HH: methylene â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (sideDef === 'HH') {
      if (showH) {
        [dir1, dir2].forEach(d => {
          const hp = bkPos[i].clone().addScaledVector(d, 1.09);
          addSphere('H', hp, hGrp);
          addBond(bkPos[i], hp, hGrp, BOND_R*.7);
          totalAtoms++;
        });
      }

    // â”€â”€ HMe: methine CH(CHâ‚ƒ) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    } else if (sideDef === 'HMe') {
      const mePos = bkPos[i].clone().addScaledVector(dir1, 1.54);
      addSphere('C', mePos, sideAtomGrp, merColor);
      addBond(bkPos[i], mePos, bondGrp);
      totalAtoms++;
      if (showH) {
        terminalDirs(mePos, bkPos[i]).forEach(d => {
          const hp = mePos.clone().addScaledVector(d, 1.09);
          addSphere('H', hp, hGrp);
          addBond(mePos, hp, hGrp, BOND_R*.7);
          totalAtoms++;
        });
        const hp = bkPos[i].clone().addScaledVector(dir2, 1.09);
        addSphere('H', hp, hGrp);
        addBond(bkPos[i], hp, hGrp, BOND_R*.7);
        totalAtoms++;
      }

    // â”€â”€ HCl: atactic CHCl â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    } else if (sideDef === 'HCl') {
      const r    = srand(i*31+7);
      const cDir = r < .5 ? dir1 : dir2;
      const hDir = r < .5 ? dir2 : dir1;
      const cPos = bkPos[i].clone().addScaledVector(cDir, 1.77);
      addSphere('Cl', cPos, sideAtomGrp);
      addBond(bkPos[i], cPos, bondGrp);
      totalAtoms++;
      if (showH) {
        const hp = bkPos[i].clone().addScaledVector(hDir, 1.09);
        addSphere('H', hp, hGrp);
        addBond(bkPos[i], hp, hGrp, BOND_R*.7);
        totalAtoms++;
      }

    // â”€â”€ HPh: methine CH(Ph) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    } else if (sideDef === 'HPh') {
      const ipsoPos = bkPos[i].clone().addScaledVector(dir1, 1.51);
      const bbTan   = new THREE.Vector3().subVectors(bkPos[i+1], bkPos[i-1]).normalize();
      buildPhenyl(bkPos[i], ipsoPos, bbTan, sideAtomGrp, hGrp, bondGrp, showH, merColor);
      totalAtoms += 6;
      if (showH) {
        const hp = bkPos[i].clone().addScaledVector(dir2, 1.09);
        addSphere('H', hp, hGrp);
        addBond(bkPos[i], hp, hGrp, BOND_R*.7);
        totalAtoms++;
      }

    // â”€â”€ MeEst: PMMA quaternary C(CHâ‚ƒ)(COOMe) â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // dir1: methyl C; dir2: ester C, then ester O
    } else if (sideDef === 'MeEst') {
      // Methyl group (dir1)
      const mePos = bkPos[i].clone().addScaledVector(dir1, 1.54);
      addSphere('C', mePos, sideAtomGrp, merColor);
      addBond(bkPos[i], mePos, bondGrp);
      totalAtoms++;
      if (showH) {
        terminalDirs(mePos, bkPos[i]).forEach(d => {
          const hp = mePos.clone().addScaledVector(d, 1.09);
          addSphere('H', hp, hGrp);
          addBond(mePos, hp, hGrp, BOND_R*.7);
          totalAtoms++;
        });
      }
      // Ester carbonyl C (dir2, 1.52 Ã…)
      const estCPos = bkPos[i].clone().addScaledVector(dir2, 1.52);
      addSphere('C', estCPos, sideAtomGrp, merColor);
      addBond(bkPos[i], estCPos, bondGrp);
      totalAtoms++;
      // Carbonyl O (=O, 1.22 Ã… beyond ester C, continuing dir2)
      const estOPos = estCPos.clone().addScaledVector(dir2, 1.22);
      addSphere('O', estOPos, sideAtomGrp);
      addDoubleBond(estCPos, estOPos, bondGrp);
      totalAtoms++;
      // Ester O-CHâ‚ƒ: place perpendicular to dir2 from estC
      const perp = new THREE.Vector3().crossVectors(dir2, new THREE.Vector3(0,1,0)).normalize();
      if (perp.length() < 0.1) perp.set(1,0,0);
      const estOm = estCPos.clone().addScaledVector(perp, 1.36);
      addSphere('O', estOm, sideAtomGrp);
      addBond(estCPos, estOm, bondGrp);
      totalAtoms++;
      // Methyl O-CHâ‚ƒ
      const omcPos = estOm.clone().addScaledVector(perp, 1.43);
      addSphere('C', omcPos, sideAtomGrp, merColor);
      addBond(estOm, omcPos, bondGrp);
      totalAtoms++;
      if (showH) {
        terminalDirs(omcPos, estOm).forEach(d => {
          const hp = omcPos.clone().addScaledVector(d, 1.09);
          addSphere('H', hp, hGrp);
          addBond(omcPos, hp, hGrp, BOND_R*.7);
          totalAtoms++;
        });
      }

    // â”€â”€ FF: difluoromethylene CFâ‚‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    } else if (sideDef === 'FF') {
      [dir1, dir2].forEach(d => {
        const fPos = bkPos[i].clone().addScaledVector(d, 1.35);
        addSphere('F', fPos, sideAtomGrp);
        addBond(bkPos[i], fPos, bondGrp);
        totalAtoms++;
      });

    // â”€â”€ Me: sp2 =C(CHâ‚ƒ) â€” single methyl, no H on C â”€â”€â”€
    } else if (sideDef === 'Me') {
      const mePos = bkPos[i].clone().addScaledVector(dir1, 1.51);  // sp2 C-C slightly shorter
      addSphere('C', mePos, sideAtomGrp, merColor);
      addBond(bkPos[i], mePos, bondGrp);
      totalAtoms++;
      if (showH) {
        terminalDirs(mePos, bkPos[i]).forEach(d => {
          const hp = mePos.clone().addScaledVector(d, 1.09);
          addSphere('H', hp, hGrp);
          addBond(mePos, hp, hGrp, BOND_R*.7);
          totalAtoms++;
        });
      }

    // â”€â”€ H1: sp2 =CHâ€” single H â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    } else if (sideDef === 'H1') {
      if (showH) {
        const hp = bkPos[i].clone().addScaledVector(dir1, 1.08);  // sp2 C-H shorter
        addSphere('H', hp, hGrp);
        addBond(bkPos[i], hp, hGrp, BOND_R*.7);
        totalAtoms++;
      }

    // â”€â”€ HN: backbone N with N-H â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    } else if (sideDef === 'HN') {
      if (showH) {
        const hp = bkPos[i].clone().addScaledVector(dir1, 1.01);  // N-H bond length
        addSphere('H', hp, hGrp);
        addBond(bkPos[i], hp, hGrp, BOND_R*.65);
        totalAtoms++;
      }

    // â”€â”€ C=O: backbone carbonyl (double bond) â”€â”€â”€â”€â”€â”€â”€â”€
    } else if (sideDef === 'C=O') {
      const oPos = bkPos[i].clone().addScaledVector(dir1, 1.22);  // C=O bond length
      addSphere('O', oPos, sideAtomGrp);
      addDoubleBond(bkPos[i], oPos, bondGrp);
      totalAtoms++;

    // â”€â”€ MeMe: PDMS Si(CHâ‚ƒ)â‚‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    } else if (sideDef === 'MeMe') {
      [dir1, dir2].forEach(d => {
        const mePos = bkPos[i].clone().addScaledVector(d, 1.87);  // Si-C bond length
        addSphere('C', mePos, sideAtomGrp, merColor);
        addBond(bkPos[i], mePos, bondGrp);
        totalAtoms++;
        if (showH) {
          terminalDirs(mePos, bkPos[i]).forEach(hd => {
            const hp = mePos.clone().addScaledVector(hd, 1.09);
            addSphere('H', hp, hGrp);
            addBond(mePos, hp, hGrp, BOND_R*.7);
            totalAtoms++;
          });
        }
      });

    // â”€â”€ PhBB: backbone-bridging para-phenylene ring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // backbone atom i = Câ‚ (ipso); backbone atom i+1 = Câ‚„ (para, skipBond:true)
    // builds Câ‚‚,Câ‚ƒ,Câ‚…,Câ‚† as side atoms; ring bonds in both bondGrp and bbBondGrp
    } else if (sideDef === 'PhBB') {
      if (i + 1 < N) {
        const C1 = bkPos[i];
        const C4 = bkPos[i + 1];
        const axis   = new THREE.Vector3().subVectors(C4, C1).normalize();
        const center = C1.clone().add(C4).multiplyScalar(0.5);
        // perpendicular to axis, in the local plane of the backbone
        let inDir = (i > 0)
          ? new THREE.Vector3().subVectors(C1, bkPos[i-1]).normalize()
          : new THREE.Vector3(0,1,0);
        let perp = new THREE.Vector3().crossVectors(axis, inDir);
        if (perp.length() < 0.01) {
          const ref2 = Math.abs(axis.x) < 0.9 ? new THREE.Vector3(1,0,0) : new THREE.Vector3(0,1,0);
          perp.crossVectors(axis, ref2);
        }
        perp.normalize();
        const L = 1.40;
        const ring = [];
        // Starting at 180Â° places ring[0] near C1 and ring[3] near C4
        for (let j = 0; j < 6; j++) {
          const angle = (180 + j * 60) * DEG;
          ring.push(center.clone()
            .addScaledVector(axis, L * Math.cos(angle))
            .addScaledVector(perp, L * Math.sin(angle)));
        }
        ring[0] = C1.clone();   // ipso  = actual backbone C1
        ring[3] = C4.clone();   // para  = actual backbone C4
        // Add the 4 ortho/meta ring carbons to bbAtomGrp (visible in backbone-only mode)
        [ring[1], ring[2], ring[4], ring[5]].forEach(p => {
          addSphere('C', p, bbAtomGrp, merColor);
          totalAtoms++;
        });
        // Ring bonds â€” KekulÃ© alternating: 0-1, 2-3, 4-5 are double
        for (let j = 0; j < 6; j++) {
          const from = ring[j], to = ring[(j+1)%6];
          if (j % 2 === 0) {
            addDoubleBond(from, to, bondGrp);
            addDoubleBond(from, to, bbBondGrp);
          } else {
            addBond(from, to, bondGrp);
            addBond(from, to, bbBondGrp);
          }
        }
        // Aromatic H on ortho/meta carbons
        if (showH) {
          [ring[1], ring[2], ring[4], ring[5]].forEach(p => {
            const hDir = p.clone().sub(center).normalize();
            const hPos = p.clone().addScaledVector(hDir, 1.08);
            addSphere('H', hPos, hGrp);
            addBond(p, hPos, hGrp, BOND_R * 0.7);
            totalAtoms++;
          });
        }
      }

    // â”€â”€ HEMASide: pHEMA quaternary C(CHâ‚ƒ)(COOCHâ‚‚CHâ‚‚OH) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    } else if (sideDef === 'HEMASide') {
      // Methyl group (dir1)
      const mePos2 = bkPos[i].clone().addScaledVector(dir1, 1.54);
      addSphere('C', mePos2, sideAtomGrp, merColor);
      addBond(bkPos[i], mePos2, bondGrp);
      totalAtoms++;
      if (showH) {
        terminalDirs(mePos2, bkPos[i]).forEach(d => {
          const hp = mePos2.clone().addScaledVector(d, 1.09);
          addSphere('H', hp, hGrp); addBond(mePos2, hp, hGrp, BOND_R*.7); totalAtoms++;
        });
      }
      // Ester carbonyl C (dir2, 1.52 Ã…)
      const eCPos = bkPos[i].clone().addScaledVector(dir2, 1.52);
      addSphere('C', eCPos, sideAtomGrp, merColor);
      addBond(bkPos[i], eCPos, bondGrp); totalAtoms++;
      // Carbonyl =O (double bond, 1.22 Ã… along dir2)
      const eCO = eCPos.clone().addScaledVector(dir2, 1.22);
      addSphere('O', eCO, sideAtomGrp);
      addDoubleBond(eCPos, eCO, bondGrp); totalAtoms++;
      // Ester â€“Oâ€“ bridge (perpendicular to dir2)
      let perp3 = new THREE.Vector3().crossVectors(dir2, new THREE.Vector3(0,1,0));
      if (perp3.length() < 0.1) perp3 = new THREE.Vector3().crossVectors(dir2, new THREE.Vector3(1,0,0));
      perp3.normalize();
      const eO1 = eCPos.clone().addScaledVector(perp3, 1.36);
      addSphere('O', eO1, sideAtomGrp);
      addBond(eCPos, eO1, bondGrp); totalAtoms++;
      // â€“CHâ‚‚â€“ (a)
      const eC2a = eO1.clone().addScaledVector(perp3, 1.43);
      addSphere('C', eC2a, sideAtomGrp, merColor);
      addBond(eO1, eC2a, bondGrp); totalAtoms++;
      if (showH) {
        terminalDirs(eC2a, eO1).slice(0,2).forEach(d => {
          const hp = eC2a.clone().addScaledVector(d, 1.09);
          addSphere('H', hp, hGrp); addBond(eC2a, hp, hGrp, BOND_R*.7); totalAtoms++;
        });
      }
      // â€“CHâ‚‚â€“ (b)
      const eC2b = eC2a.clone().addScaledVector(perp3, 1.54);
      addSphere('C', eC2b, sideAtomGrp, merColor);
      addBond(eC2a, eC2b, bondGrp); totalAtoms++;
      if (showH) {
        terminalDirs(eC2b, eC2a).slice(0,2).forEach(d => {
          const hp = eC2b.clone().addScaledVector(d, 1.09);
          addSphere('H', hp, hGrp); addBond(eC2b, hp, hGrp, BOND_R*.7); totalAtoms++;
        });
      }
      // â€“OH terminal
      const eOH = eC2b.clone().addScaledVector(perp3, 1.43);
      addSphere('O', eOH, sideAtomGrp);
      addBond(eC2b, eOH, bondGrp); totalAtoms++;
      if (showH) {
        const hODir = new THREE.Vector3().crossVectors(perp3, dir2).normalize();
        const hOPos = eOH.clone().addScaledVector(hODir, 0.96);
        addSphere('H', hOPos, hGrp); addBond(eOH, hOPos, hGrp, BOND_R*.65); totalAtoms++;
      }
    }
  }

  return { bbAtomGrp, sideAtomGrp, hGrp, bondGrp, bbBondGrp, extent, totalAtoms };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  THREE.JS SCENE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const wrap     = document.getElementById('canvas-wrap');
const scene    = new THREE.Scene();
scene.background = new THREE.Color(0x12131a);
scene.fog = new THREE.FogExp2(0x12131a, 0.0025);

const camera   = new THREE.PerspectiveCamera(40, wrap.clientWidth/wrap.clientHeight, .05, 600);
camera.position.set(0, 12, 45);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(wrap.clientWidth, wrap.clientHeight);
wrap.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.dampingFactor = 0.07;
controls.target.set(0,0,0); controls.update();

scene.add(new THREE.AmbientLight(0xffffff, .42));
const sun  = new THREE.DirectionalLight(0xffffff, .88); sun.position.set(8,12,10);  scene.add(sun);
const fill = new THREE.DirectionalLight(0x8899ff, .20); fill.position.set(-6,-5,-9); scene.add(fill);
const rim  = new THREE.DirectionalLight(0xffeedd, .12); rim.position.set(0,-8,-12);  scene.add(rim);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  APP STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let activeKey    = 'PE';
let numMers      = 30;
let showH        = false;
let autoSpin     = false;
let backboneOnly = false;
let colourMers   = false;
let conformMode  = 'crystal';
let chainGroup   = null;

function activeCat() { return POLYMERS[activeKey] ? POLYMERS[activeKey].cat : 'addition'; }

function updateInfoPanel(key, mode) {
  const p    = POLYMERS[key];
  const info = p.info[mode] || p.info.crystal;
  document.getElementById('inf-name').textContent    = p.name;
  document.getElementById('inf-formula').textContent = p.formula;
  document.getElementById('inf-synth').textContent   = p.synth;
  document.getElementById('inf-conf').textContent    = (p.conf[mode] || p.conf.crystal);
  document.getElementById('inf-tg').textContent      = info.Tg;
  document.getElementById('inf-tm').textContent      = info.Tm;
  document.getElementById('inf-density').textContent = info.density;
  document.getElementById('inf-desc').textContent    = info.desc;
  const badgeText = p.badge[mode] || p.badge.crystal;
  const badgeEl   = document.getElementById('badge');
  badgeEl.textContent = badgeText;
  // Badge colour: cat + mode
  const cat = p.cat;
  badgeEl.className = 'badge'
    + (cat === 'condensation' ? ' condensation' : '')
    + (mode === 'amorphous'   ? ' amorphous'    : '');
}

function frameCamera(extent) {
  const dist = Math.max(extent * 3.2, 18);
  camera.position.set(dist*.15, dist*.45, dist);
  controls.target.set(0,0,0);
  controls.update();
}

function rebuildChain() {
  const nBk       = numMers * POLYMERS[activeKey].backbone.length;
  const hasPhenyl = POLYMERS[activeKey].backbone.some(b => b.side === 'HPh');
  const hasMeEst  = POLYMERS[activeKey].backbone.some(b => b.side === 'MeEst' || b.side === 'HEMASide');
  const nPhBB     = POLYMERS[activeKey].backbone.filter(b => b.side === 'PhBB').length;  // rings/mer
  const gLoad     = nBk * (hasPhenyl ? 4 : nPhBB > 0 ? (2 + nPhBB) : hasMeEst ? 3 : 1);
  _ql = gLoad > 400 ? 2 : gLoad > 200 ? 1 : 0;
  document.getElementById('perf-warn').style.display = (_ql > 0) ? 'block' : 'none';

  if (chainGroup) { disposeGroup(chainGroup); scene.remove(chainGroup); }
  chainGroup = new THREE.Group();

  const { bbAtomGrp, sideAtomGrp, hGrp, bondGrp, bbBondGrp, extent, totalAtoms }
    = buildChain(activeKey, numMers, showH, colourMers, conformMode);

  if (backboneOnly) {
    chainGroup.add(bbAtomGrp); chainGroup.add(bbBondGrp);
    disposeGroup(bondGrp);
  } else {
    chainGroup.add(bbAtomGrp); chainGroup.add(sideAtomGrp); chainGroup.add(bondGrp);
    if (showH) chainGroup.add(hGrp); else disposeGroup(hGrp);
  }
  scene.add(chainGroup);
  frameCamera(extent);

  const nBkDisp = numMers * POLYMERS[activeKey].backbone.length;
  document.getElementById('atom-count-badge').textContent =
    `${numMers} mer units Â· ${nBkDisp} backbone atoms` +
    (showH ? ` Â· ${totalAtoms} total (with H)` : '');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UI HANDLERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
document.querySelectorAll('.poly-btn:not(.disabled)').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.poly-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    activeKey = btn.dataset.key;
    updateInfoPanel(activeKey, conformMode);
    rebuildChain();
  });
});

document.getElementById('btn-crystal').addEventListener('click', function () {
  conformMode = 'crystal';
  this.classList.add('active');
  document.getElementById('btn-amor').classList.remove('active');
  updateInfoPanel(activeKey, conformMode);
  rebuildChain();
});
document.getElementById('btn-amor').addEventListener('click', function () {
  conformMode = 'amorphous';
  this.classList.add('active');
  document.getElementById('btn-crystal').classList.remove('active');
  updateInfoPanel(activeKey, conformMode);
  rebuildChain();
});

const merSlider = document.getElementById('mer-slider');
const merValEl  = document.getElementById('mer-val');
merSlider.addEventListener('input', () => {
  numMers = parseInt(merSlider.value, 10);
  merValEl.textContent = numMers;
  rebuildChain();
});

document.getElementById('btn-H').addEventListener('click', function () {
  showH = !showH; this.classList.toggle('on', showH); rebuildChain();
});
document.getElementById('btn-spin').addEventListener('click', function () {
  autoSpin = !autoSpin; this.classList.toggle('on', autoSpin);
});
document.getElementById('btn-backbone').addEventListener('click', function () {
  backboneOnly = !backboneOnly; this.classList.toggle('on', backboneOnly); rebuildChain();
});
document.getElementById('btn-mers').addEventListener('click', function () {
  colourMers = !colourMers; this.classList.toggle('on', colourMers); rebuildChain();
});

renderer.domElement.addEventListener('dblclick', () => {
  if (chainGroup) {
    let maxD = 0;
    chainGroup.traverse(o => { if (o.isMesh) { const d=o.position.length(); if(d>maxD)maxD=d; } });
    frameCamera(maxD);
  }
});

window.addEventListener('resize', () => {
  camera.aspect = wrap.clientWidth / wrap.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(wrap.clientWidth, wrap.clientHeight);
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ANIMATION LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function animate() {
  requestAnimationFrame(animate);
  if (autoSpin && chainGroup) chainGroup.rotation.y += 0.005;
  controls.update();
  renderer.render(scene, camera);
}

updateInfoPanel(activeKey, conformMode);
rebuildChain();
animate();
</script>
</body>
</html>
