<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Manufacturing Processes</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, sans-serif;
      background: #12131a;
      color: #dde1f0;
      display: flex;
      height: 100vh;
      overflow: hidden;
    }

    #sidebar {
      width: 270px;
      min-width: 270px;
      background: #1a1d2e;
      border-right: 1px solid #2a2d45;
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 20px 16px;
      overflow-y: auto;
    }
    #sidebar h1 {
      font-size: 1rem;
      font-weight: 700;
      color: #7eb8f7;
      text-transform: uppercase;
      letter-spacing: 2px;
      border-bottom: 1px solid #2a2d45;
      padding-bottom: 12px;
    }
    .section-label {
      font-size: 0.68rem;
      font-weight: 700;
      color: #5a6080;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      margin-bottom: 7px;
    }

    /* 2-column category grid */
    .cat-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
    }
    .class-group { margin-bottom: 6px; }
    .class-header {
      font-size: 0.60rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      padding: 3px 7px;
      margin-bottom: 5px;
      border-radius: 4px;
    }
    .class-header.primary   { color:#5ab0f0; border-left:2px solid #5ab0f0; background:rgba(90,176,240,.08); }
    .class-header.secondary { color:#f07850; border-left:2px solid #f07850; background:rgba(240,120,80,.08); }
    .cat-btn {
      padding: 9px 4px;
      background: #1e2238;
      border: 1px solid #2e3355;
      border-radius: 7px;
      color: #9ba8c8;
      cursor: pointer;
      font-size: 0.70rem;
      font-weight: 600;
      text-align: center;
      line-height: 1.35;
      transition: background .18s, border-color .18s, color .18s;
    }
    .cat-btn:hover { background:#253060; border-color:#4a6bcc; color:#c8d8ff; }
    .cat-btn.active { background:#2751b8; border-color:#4a79ff; color:#fff; }

    /* Sub-process list */
    .sub-grid { display: flex; flex-direction: column; gap: 5px; }
    .sub-btn {
      padding: 8px 10px;
      background: #1e2238;
      border: 1px solid #2e3355;
      border-radius: 7px;
      color: #9ba8c8;
      cursor: pointer;
      font-size: 0.74rem;
      font-weight: 600;
      text-align: left;
      transition: background .18s, border-color .18s, color .18s;
    }
    .sub-btn:hover { background:#253060; border-color:#4a6bcc; color:#c8d8ff; }
    .sub-btn.active { background:#0e4a2a; border-color:#2aaa66; color:#66ffbb; }

    /* Info panel */
    .info-panel {
      background: #1e2238;
      border: 1px solid #2a2d45;
      border-radius: 8px;
      padding: 12px 14px;
      font-size: 0.78rem;
      line-height: 2;
    }
    .info-row { display: flex; justify-content: space-between; align-items: baseline; gap: 8px; }
    .info-key { color: #5a6080; font-size: 0.71rem; white-space: nowrap; }
    .info-val { color: #c8d8ff; font-weight: 600; font-size: 0.74rem; text-align: right; }

    /* Details panel */
    .details-panel {
      background: #161828; border: 1px solid #2a2d45;
      border-radius: 8px; padding: 10px 12px;
      display: flex; flex-direction: column; gap: 7px;
      font-size: 0.72rem;
    }
    .det-hrow { display:flex; justify-content:space-between; align-items:center; }
    .det-key  { color:#5a6080; font-size:0.63rem; font-weight:700; text-transform:uppercase; letter-spacing:.8px; }
    .det-complexity { font-weight:700; font-size:0.68rem; padding:2px 7px; border-radius:3px; }
    .det-complexity.low       { color:#66cc88; background:rgba(100,200,120,.13); }
    .det-complexity.moderate  { color:#e0c040; background:rgba(220,190,60,.13); }
    .det-complexity.high      { color:#f09040; background:rgba(240,140,60,.13); }
    .det-complexity.very-high { color:#e06060; background:rgba(220,80,80,.13); }
    .det-complexity-sub { color:#5a6888; font-size:0.65rem; line-height:1.4; font-style:italic; }
    .det-group-lbl { font-size:0.62rem; font-weight:700; text-transform:uppercase; letter-spacing:.8px; margin-bottom:3px; }
    .det-group-lbl.pro { color:#3a8a54; }
    .det-group-lbl.con { color:#8a3a3a; }
    .det-item { display:flex; gap:5px; font-size:0.68rem; line-height:1.4; margin-bottom:2px; }
    .det-item .dot { flex-shrink:0; margin-top:1px; font-size:0.7rem; }
    .det-item.pro { color:#90c8a8; } .det-item.pro .dot { color:#55bb77; }
    .det-item.con { color:#c89090; } .det-item.con .dot { color:#bb5555; }
    .det-tol-row { display:flex; justify-content:space-between; align-items:center; padding-top:5px; border-top:1px solid #1e2238; }
    .det-val { color:#8898b8; font-size:0.70rem; }

    /* Controls */
    .ctrl-row { display: flex; gap: 8px; }
    .ctrl-btn {
      flex: 1;
      padding: 8px;
      background: #1e2238;
      border: 1px solid #2e3355;
      border-radius: 7px;
      color: #9ba8c8;
      cursor: pointer;
      font-size: 0.76rem;
      font-weight: 600;
      transition: background .18s, border-color .18s, color .18s;
    }
    .ctrl-btn:hover { background:#253060; border-color:#4a6bcc; color:#c8d8ff; }
    .ctrl-btn.running { background:#2751b8; border-color:#4a79ff; color:#fff; }

    .spd-row { display: flex; flex-direction: column; gap: 5px; margin-top: 10px; }
    .spd-lbl { display: flex; justify-content: space-between; font-size: .73rem; }
    .spd-lbl span:first-child { color:#6878a0; }
    .spd-lbl span:last-child  { color:#c8d8ff; font-weight:600; }
    input[type=range] { width:100%; accent-color:#4a79ff; }

    .hint { font-size:.71rem; color:#454a65; line-height:1.85; }

    /* Step buttons */
    .step-section { display:none; }
    .step-section.visible { display:block; }
    .step-grid { display:flex; flex-direction:column; gap:5px; }
    .step-btn {
      padding:7px 10px;
      background:#1e2238; border:1px solid #2e3355; border-radius:7px;
      color:#9ba8c8; cursor:pointer; font-size:.73rem; font-weight:600;
      text-align:left; transition:background .18s, border-color .18s, color .18s;
    }
    .step-btn:hover  { background:#253060; border-color:#4a6bcc; color:#c8d8ff; }
    .step-btn.active { background:#2a1808; border-color:#c07030; color:#ffcc88; }

    /* Canvas */
    #canvas-wrap { flex:1; position:relative; overflow:hidden; background:#0d0f1a; }
    canvas { display:block; }
    .stage-badge {
      position:absolute; top:12px; right:14px;
      background:rgba(39,81,184,.25); border:1px solid #2751b8;
      border-radius:5px; padding:4px 12px;
      font-size:.72rem; color:#7eb8f7; pointer-events:none;
    }
  </style>
</head>
<body>

<div id="sidebar">
  <h1>Manufacturing<br>Processes</h1>

  <div>
    <div class="section-label">Category</div>
    <div class="class-group">
      <div class="class-header primary">Primary Shaping</div>
      <div class="cat-grid">
        <button class="cat-btn active" data-cat="casting">Casting</button>
        <button class="cat-btn"        data-cat="forming">Forming</button>
        <button class="cat-btn"        data-cat="molding">Molding</button>
        <button class="cat-btn"        data-cat="additive">Additive</button>
      </div>
    </div>
    <div class="class-group">
      <div class="class-header secondary">Secondary Shaping</div>
      <div class="cat-grid">
        <button class="cat-btn"        data-cat="machining">Machining</button>
        <button class="cat-btn"        data-cat="joining">Joining</button>
      </div>
    </div>
  </div>

  <div>
    <div class="section-label">Process</div>
    <div class="sub-grid" id="sub-grid"></div>
  </div>

  <div class="step-section" id="step-section">
    <div class="section-label">Steps</div>
    <div class="step-grid" id="step-grid"></div>
  </div>

  <div>
    <div class="section-label">Info</div>
    <div class="info-panel">
      <div class="info-row"><span class="info-key">Process</span>    <span class="info-val" id="inf-name">Sand Casting</span></div>
      <div class="info-row"><span class="info-key">Materials</span>   <span class="info-val" id="inf-mat">Metals, Alloys</span></div>
      <div class="info-row"><span class="info-key">Temperature</span> <span class="info-val" id="inf-temp">700–1600 °C</span></div>
      <div class="info-row"><span class="info-key">Stage</span>        <span class="info-val" id="inf-stage">—</span></div>
    </div>
  </div>

  <div id="details-section" style="display:none">
    <div class="section-label">Details</div>
    <div class="details-panel">
      <div class="det-hrow">
        <span class="det-key">Complexity</span>
        <span class="det-complexity" id="det-complexity">—</span>
      </div>
      <div class="det-complexity-sub" id="det-complexity-sub"></div>
      <div>
        <div class="det-group-lbl pro">Benefits</div>
        <div id="det-pros"></div>
      </div>
      <div>
        <div class="det-group-lbl con">Drawbacks</div>
        <div id="det-cons"></div>
      </div>
      <div class="det-tol-row">
        <span class="det-key">Typical Tolerance</span>
        <span class="det-val" id="det-tolerance">—</span>
      </div>
    </div>
  </div>

  <div>
    <div class="section-label">Controls</div>
    <div class="ctrl-row">
      <button class="ctrl-btn running" id="btn-play">⏸ Pause</button>
      <button class="ctrl-btn"          id="btn-reset">↺ Reset</button>
    </div>
    <div class="spd-row">
      <div class="spd-lbl"><span>Speed</span><span id="spd-val">1×</span></div>
      <input type="range" id="spd-slider" min="0.25" max="4" step="0.25" value="1">
    </div>
  </div>

  <p class="hint">Animated 2D schematic cross-sections of the six main manufacturing process families, inspired by <em>The Efficient Engineer</em>.</p>
</div>

<div id="canvas-wrap">
  <canvas id="canvas"></canvas>
  <div class="stage-badge" id="stage-badge">Sand Casting · Filling</div>
</div>

<script>
// ══════════════════════════════════════
//  CANVAS
// ══════════════════════════════════════
const canvas = document.getElementById('canvas');
const ctx    = canvas.getContext('2d');
let W = 0, H = 0;

// Declare these here so resizeCanvas can safely reference them
let currentSim = null, running = true, speed = 1, animId = null, lastTs = 0;

function resizeCanvas() {
  const wrap = document.getElementById('canvas-wrap');
  W = canvas.width  = wrap.clientWidth;
  H = canvas.height = wrap.clientHeight;
  if (currentSim) currentSim.onResize();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// ══════════════════════════════════════
//  UTILITIES
// ══════════════════════════════════════
const lerp  = (a,b,t) => a+(b-a)*t;
const clamp = (v,lo,hi) => Math.max(lo,Math.min(hi,v));
const sat   = t => clamp(t,0,1);
const ease  = t => t<.5 ? 2*t*t : -1+(4-2*t)*t;
const easeO = t => t*(2-t);

function rrect(x,y,w,h,r=6){
  r=Math.min(r,w/2,h/2);
  ctx.beginPath();
  ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.arcTo(x+w,y,x+w,y+r,r);
  ctx.lineTo(x+w,y+h-r); ctx.arcTo(x+w,y+h,x+w-r,y+h,r);
  ctx.lineTo(x+r,y+h); ctx.arcTo(x,y+h,x,y+h-r,r);
  ctx.lineTo(x,y+r); ctx.arcTo(x,y,x+r,y,r);
  ctx.closePath();
}

function arrow(x1,y1,x2,y2,col='#ffc040',lw=2,hs=10){
  const dx=x2-x1,dy=y2-y1,len=Math.hypot(dx,dy);
  if(len<1) return;
  const ux=dx/len,uy=dy/len;
  ctx.save(); ctx.strokeStyle=col; ctx.lineWidth=lw;
  ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  ctx.fillStyle=col; ctx.beginPath();
  ctx.moveTo(x2,y2);
  ctx.lineTo(x2-hs*(ux+uy*.45),y2-hs*(uy-ux*.45));
  ctx.lineTo(x2-hs*(ux-uy*.45),y2-hs*(uy+ux*.45));
  ctx.closePath(); ctx.fill(); ctx.restore();
}

function lbl(text,x,y,{align='center',color='#8090b4',size=11,bold=false}={}){
  ctx.save();
  ctx.font=`${bold?'700 ':''}${size}px 'Segoe UI',sans-serif`;
  ctx.fillStyle=color; ctx.textAlign=align;
  ctx.fillText(text,x,y); ctx.restore();
}

function hatch(x,y,w,h,sp=9,col='rgba(0,0,0,.35)'){
  ctx.save(); ctx.strokeStyle=col; ctx.lineWidth=1;
  ctx.beginPath();
  const d=Math.hypot(w,h);
  for(let i=-d;i<d*2;i+=sp){
    ctx.moveTo(x+i, y); ctx.lineTo(x+i-h, y+h);
  }
  ctx.save(); ctx.beginPath(); ctx.rect(x,y,w,h); ctx.clip(); ctx.stroke();
  ctx.restore(); ctx.restore();
}

function grid(){
  ctx.fillStyle='#0d0f1a'; ctx.fillRect(0,0,W,H);
  ctx.strokeStyle='rgba(255,255,255,.028)'; ctx.lineWidth=1;
  ctx.beginPath();
  for(let x=0;x<=W;x+=40){ctx.moveTo(x,0);ctx.lineTo(x,H);}
  for(let y=0;y<=H;y+=40){ctx.moveTo(0,y);ctx.lineTo(W,y);}
  ctx.stroke();
}

// Thin-line rotational motion indicator on a circle
function spinMark(cx,cy,r,t,col='rgba(200,220,255,.4)'){
  ctx.save(); ctx.strokeStyle=col; ctx.lineWidth=1.5;
  for(let i=0;i<8;i++){
    const a=(i/8)*Math.PI*2+t*Math.PI*6;
    ctx.beginPath();
    ctx.moveTo(cx+(r*.55)*Math.cos(a),cy+(r*.55)*Math.sin(a));
    ctx.lineTo(cx+r*.9*Math.cos(a),cy+r*.9*Math.sin(a));
    ctx.stroke();
  }
  ctx.restore();
}

// Molten-material color (orange→dark red as it solidifies)
function moltCol(solid){
  const r=lerp(255,140,solid), g=lerp(120,50,solid), b=lerp(0,20,solid);
  return `rgb(${r|0},${g|0},${b|0})`;
}

// ══════════════════════════════════════
//  ANIMATION FRAMEWORK
// ══════════════════════════════════════
// (currentSim, running, speed, animId, lastTs declared near top with canvas setup)

function animate(ts){
  const dt=Math.min((ts-lastTs)/1000,.05)*speed;
  lastTs=ts;
  try {
    if(running && currentSim) currentSim.step(dt);
    if(currentSim) currentSim.draw();
  } catch(e) {
    document.getElementById('stage-badge').textContent = 'ERR: ' + e.message;
    console.error('animate error:', e);
  }
  animId=requestAnimationFrame(animate);
}

function loadSim(sim){
  if(currentSim && currentSim.cleanup) currentSim.cleanup();
  currentSim=sim;
  if(sim.steps){ sim.currentStep=0; }
  sim.init();
  document.getElementById('inf-name').textContent  = sim.meta.name;
  document.getElementById('inf-mat').textContent   = sim.meta.mat;
  document.getElementById('inf-temp').textContent  = sim.meta.temp;
  document.getElementById('inf-stage').textContent = '—';
  buildStepMenu(sim);
  buildDetails(sim);
}

function buildDetails(sim){
  const key=Object.keys(SIMS).find(k=>SIMS[k].sim===sim);
  const d=key?DETAILS[key]:null;
  const section=document.getElementById('details-section');
  if(!d){ section.style.display='none'; return; }
  section.style.display='';

  // Complexity badge
  const ct=d.complexity;
  let level,label;
  if(ct.startsWith('Very High'))        { level='very-high'; label='Very High'; }
  else if(ct.startsWith('High'))         { level='high';      label='High'; }
  else if(ct.startsWith('Moderate–High')){ level='high';      label='Moderate–High'; }
  else if(ct.startsWith('Low–Moderate')) { level='moderate';  label='Low–Moderate'; }
  else if(ct.startsWith('Moderate'))     { level='moderate';  label='Moderate'; }
  else                                   { level='low';       label='Low'; }
  const ce=document.getElementById('det-complexity');
  ce.className='det-complexity '+level; ce.textContent=label;
  document.getElementById('det-complexity-sub').textContent=ct.split('—').slice(1).join('—').trim();

  // Pros / cons
  document.getElementById('det-pros').innerHTML=
    d.pros.map(p=>`<div class="det-item pro"><span class="dot">✓</span><span>${p}</span></div>`).join('');
  document.getElementById('det-cons').innerHTML=
    d.cons.map(c=>`<div class="det-item con"><span class="dot">✗</span><span>${c}</span></div>`).join('');

  // Tolerance
  document.getElementById('det-tolerance').textContent=d.tolerance||'—';
}

function buildStepMenu(sim){
  const section=document.getElementById('step-section');
  const grid=document.getElementById('step-grid');
  grid.innerHTML='';
  if(!sim.steps||!sim.steps.length){ section.classList.remove('visible'); return; }
  section.classList.add('visible');
  sim.steps.forEach((step,i)=>{
    const btn=document.createElement('button');
    btn.className='step-btn'+(i===0?' active':'');
    btn.textContent=`${i+1}. ${step.label}`;
    btn.dataset.step=i;
    btn.addEventListener('click',()=>selectStep(i));
    grid.appendChild(btn);
  });
}

function selectStep(n){
  document.querySelectorAll('.step-btn').forEach(b=>b.classList.toggle('active',+b.dataset.step===n));
  if(currentSim){ currentSim.currentStep=n; currentSim.init(); }
}

function setStage(stage,simName){
  document.getElementById('inf-stage').textContent=stage;
  document.getElementById('stage-badge').textContent=`${simName} · ${stage}`;
}

// ══════════════════════════════════════
//  CASTING — SAND CASTING
// ══════════════════════════════════════
const SandCasting = {
  meta:{name:'Sand Casting',mat:'Metals, Alloys',temp:'700–1600 °C',cat:'Casting'},
  steps:[
    {label:'Pattern & Mold Making', period:9},
    {label:'Gating System',         period:8},
    {label:'Pouring',               period:11},
    {label:'Solidification',        period:12},
  ],
  currentStep:0, t:0,
  init(){ this.t=0; },
  onResize(){},
  step(dt){ this.t=(this.t+dt/(this.steps[this.currentStep]?.period||9))%1; },
  draw(){
    grid();
    switch(this.currentStep){
      case 0: this.s0(); break;
      case 1: this.s1(); break;
      case 2: this.s2(); break;
      default:this.s3(); break;
    }
  },
  // ── Shared geometry ────────────────────────────────
  _geom(){
    const cx=W/2, cy=H*.47;
    const mw=Math.min(W*.60,440), mh=Math.min(H*.52,300);
    const mx=cx-mw/2, my=cy-mh/2, hH=mh/2;
    const cvW=mw*.28, cvH=mh*.44;
    const cvX=cx-cvW/2, cvTop=cy-cvH/2;
    const spW=18, spX=mx+mw*.18;   // sprue centre-x
    const rsW=14, rsX=mx+mw*.82;   // riser centre-x
    const runH=13;
    return {cx,cy,mw,mh,mx,my,hH,cvW,cvH,cvX,cvTop,spW,spX,rsW,rsX,runH};
  },
  // ── Draw a sand block ──────────────────────────────
  _sand(x,y,w,h){
    ctx.fillStyle='#5c4828'; rrect(x,y,w,h,5); ctx.fill();
    hatch(x,y,w,h,10,'rgba(0,0,0,.30)');
    ctx.strokeStyle='#3a2c10'; ctx.lineWidth=2; rrect(x,y,w,h,5); ctx.stroke();
  },
  // ── Draw pouring cup above sprue ───────────────────
  _cup(spX,spW,topY){
    const cw=30;
    ctx.fillStyle='#3a3020';
    ctx.beginPath();
    ctx.moveTo(spX-cw,topY-22); ctx.lineTo(spX+cw,topY-22);
    ctx.lineTo(spX+spW/2,topY); ctx.lineTo(spX-spW/2,topY);
    ctx.closePath(); ctx.fill();
    ctx.strokeStyle='#8a7240'; ctx.lineWidth=1.5; ctx.stroke();
    ctx.fillStyle='#0d0f1a';
    ctx.beginPath();
    ctx.moveTo(spX-cw+5,topY-20); ctx.lineTo(spX+cw-5,topY-20);
    ctx.lineTo(spX+spW/2-1,topY-1); ctx.lineTo(spX-spW/2+1,topY-1);
    ctx.closePath(); ctx.fill();
  },
  // ── STEP 0 : Pattern & Mold Making ────────────────
  s0(){
    const {cx,cy,mw,mh,mx,my,hH,cvW,cvH,cvX,cvTop}=this._geom();
    const t=this.t;
    let stage;
    if(t<.15)      stage='Pattern in flask';
    else if(t<.42) stage='Packing sand';
    else if(t<.60) stage='Removing pattern';
    else if(t<.82) stage='Cavity formed';
    else           stage='Mold assembled';
    setStage(stage,'Sand Casting');

    // Cope separation: opens .60→.72, holds .72→.85, closes .85→1.0
    let copeOff=0;
    if(t>=.60&&t<.72)      copeOff=easeO(sat((t-.60)/.12))*H*.20;
    else if(t>=.72&&t<.85) copeOff=H*.20;
    else if(t>=.85)        copeOff=(1-easeO(sat((t-.85)/.15)))*H*.20;

    const patA=t<.42?1:1-sat((t-.42)/.18);

    // DRAG
    this._sand(mx,cy,mw,hH);
    ctx.fillStyle='#0d0f1a'; ctx.fillRect(cvX,cy,cvW,cvH/2);
    if(patA>0){
      ctx.save(); ctx.globalAlpha=patA;
      ctx.fillStyle='#7a5c28'; ctx.fillRect(cvX+1,cy,cvW-2,cvH/2-1);
      ctx.strokeStyle='#c09030'; ctx.lineWidth=1.5; ctx.strokeRect(cvX+1,cy,cvW-2,cvH/2-1);
      for(let i=1;i<4;i++){
        ctx.strokeStyle='rgba(160,120,40,.30)'; ctx.lineWidth=1;
        ctx.beginPath(); ctx.moveTo(cvX+cvW*i/4,cy+3); ctx.lineTo(cvX+cvW*i/4,cy+cvH/2-3); ctx.stroke();
      }
      ctx.restore();
    }

    // COPE (lifted)
    ctx.save(); ctx.translate(0,-copeOff);
    this._sand(mx,my,mw,hH);
    ctx.fillStyle='#0d0f1a'; ctx.fillRect(cvX,cvTop,cvW,cvH/2);
    if(patA>0){
      ctx.save(); ctx.globalAlpha=patA;
      ctx.fillStyle='#7a5c28'; ctx.fillRect(cvX+1,cvTop,cvW-2,cvH/2-1);
      ctx.strokeStyle='#c09030'; ctx.lineWidth=1.5; ctx.strokeRect(cvX+1,cvTop,cvW-2,cvH/2-1);
      for(let i=1;i<4;i++){
        ctx.strokeStyle='rgba(160,120,40,.30)'; ctx.lineWidth=1;
        ctx.beginPath(); ctx.moveTo(cvX+cvW*i/4,cvTop+3); ctx.lineTo(cvX+cvW*i/4,cvTop+cvH/2-3); ctx.stroke();
      }
      ctx.restore();
    }
    ctx.restore();

    // Parting line
    ctx.setLineDash([5,4]); ctx.strokeStyle='rgba(120,140,180,.45)'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(mx,cy); ctx.lineTo(mx+mw,cy); ctx.stroke();
    ctx.setLineDash([]);

    lbl('COPE',mx-6,my+hH*.5+4,{align:'right',color:'#7a6840',size:10});
    lbl('DRAG',mx-6,cy+hH*.5+4, {align:'right',color:'#7a6840',size:10});
    if(patA>0.05) lbl('Pattern (wood)',cx,cy+cvH*.25,{align:'center',color:`rgba(192,144,48,${patA})`,size:10,bold:true});
    if(t>=.60){ const ca=sat((t-.60)/.15); lbl('Cavity',cx,cy+cvH*.25,{align:'center',color:`rgba(100,120,180,${ca})`,size:10}); }
    lbl('Parting line',mx+mw+6,cy,{align:'left',color:'rgba(120,140,180,.5)',size:9});
  },
  // ── STEP 1 : Gating System ─────────────────────────
  s1(){
    const {cx,cy,mw,mh,mx,my,hH,cvW,cvH,cvX,cvTop,spW,spX,rsW,rsX,runH}=this._geom();
    const t=this.t;
    const tCup=.10,tSp=.22,tRun=.38,tGate=.54,tRis=.68,tDone=.82;
    const fi=tr=>sat((t-tr)/.09);

    let stage='Assembled mold';
    if(t>tDone)      stage='Gating system complete';
    else if(t>tRis)  stage='Riser – overflow vent';
    else if(t>tGate) stage='Gate – cavity entry';
    else if(t>tRun)  stage='Runner – horizontal channel';
    else if(t>tSp)   stage='Sprue – vertical channel';
    else if(t>tCup)  stage='Pouring cup';
    setStage(stage,'Sand Casting');

    // Base mold
    this._sand(mx,cy,mw,hH);
    ctx.fillStyle='#0d0f1a'; ctx.fillRect(cvX,cy,cvW,cvH/2);
    this._sand(mx,my,mw,hH);
    ctx.fillStyle='#0d0f1a'; ctx.fillRect(cvX,cvTop,cvW,cvH/2);
    ctx.setLineDash([5,4]); ctx.strokeStyle='rgba(120,140,180,.45)'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(mx,cy); ctx.lineTo(mx+mw,cy); ctx.stroke();
    ctx.setLineDash([]);

    // Sprue void (cope)
    if(t>tSp){
      ctx.save(); ctx.globalAlpha=fi(tSp);
      ctx.fillStyle='#0d0f1a'; ctx.fillRect(spX-spW/2,my,spW,hH);
      lbl('Sprue',spX+spW/2+5,my+hH*.35,{align:'left',color:'#8898c0',size:10});
      ctx.restore();
    }
    // Pouring cup
    if(t>tCup){
      ctx.save(); ctx.globalAlpha=fi(tCup);
      this._cup(spX,spW,my);
      lbl('Pouring cup',spX,my-30,{align:'center',color:'#aaa060',size:10});
      ctx.restore();
    }
    // Runner (just below parting line, in drag surface)
    if(t>tRun){
      ctx.save(); ctx.globalAlpha=fi(tRun);
      ctx.fillStyle='#0d0f1a';
      ctx.fillRect(spX-spW/2,cy,cvX-(spX-spW/2),runH);
      lbl('Runner',(spX-spW/2+cvX)/2,cy-18,{align:'center',color:'#8898c0',size:10});
      ctx.restore();
    }
    // Gate highlight at cavity entry
    if(t>tGate){
      ctx.save(); ctx.globalAlpha=fi(tGate);
      ctx.fillStyle='rgba(255,160,40,.50)';
      ctx.fillRect(cvX-3,cy,4,runH+cvH*.10);
      arrow(cvX-22,cy+runH/2,cvX-4,cy+runH/2,'#ffaa40',2,7);
      lbl('Gate',cvX-28,cy+runH+12,{align:'right',color:'#ffaa40',size:10});
      ctx.restore();
    }
    // Riser (cope) + right runner
    if(t>tRis){
      ctx.save(); ctx.globalAlpha=fi(tRis);
      ctx.fillStyle='#0d0f1a';
      ctx.fillRect(rsX-rsW/2,my,rsW,hH);
      ctx.fillRect(cvX+cvW,cy,rsX+rsW/2-(cvX+cvW),runH);
      lbl('Riser',rsX,my+hH*.30,{align:'center',color:'#8898c0',size:10});
      ctx.restore();
    }

    lbl('COPE',mx-6,my+hH*.5+4,{align:'right',color:'#7a6840',size:10});
    lbl('DRAG',mx-6,cy+hH*.5+4, {align:'right',color:'#7a6840',size:10});
    lbl('Cavity',cx,cy+cvH*.25,  {align:'center',color:'#4a5878',size:9});
  },
  // ── STEP 2 : Pouring ───────────────────────────────
  s2(){
    const {cx,cy,mw,mh,mx,my,hH,cvW,cvH,cvX,cvTop,spW,spX,rsW,rsX,runH}=this._geom();
    const t=this.t;
    let stage;
    if(t<.08)      stage='Ready to pour';
    else if(t<.28) stage='Sprue filling';
    else if(t<.62) stage='Cavity filling';
    else if(t<.82) stage='Metal reaching riser';
    else           stage='Mold filled';
    setStage(stage,'Sand Casting');

    // Mold
    this._sand(mx,cy,mw,hH);
    ctx.fillStyle='#0d0f1a'; ctx.fillRect(cvX,cy,cvW,cvH/2);
    this._sand(mx,my,mw,hH);
    ctx.fillStyle='#0d0f1a'; ctx.fillRect(cvX,cvTop,cvW,cvH/2);
    // Gating voids
    ctx.fillStyle='#0d0f1a';
    ctx.fillRect(spX-spW/2,my,spW,hH);                          // sprue
    ctx.fillRect(spX-spW/2,cy,cvX-(spX-spW/2),runH);            // left runner
    ctx.fillRect(rsX-rsW/2,my,rsW,hH);                          // riser
    ctx.fillRect(cvX+cvW,cy,rsX+rsW/2-(cvX+cvW),runH);        // right runner
    // Parting line
    ctx.setLineDash([5,4]); ctx.strokeStyle='rgba(120,140,180,.28)'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(mx,cy); ctx.lineTo(mx+mw,cy); ctx.stroke();
    ctx.setLineDash([]);
    // Cup always shown
    this._cup(spX,spW,my);

    if(t>.08){
      const ff=sat((t-.08)/.84);
      const solid=t>.82?sat((t-.82)/.18)*.35:0;
      const col=moltCol(solid);

      // Pour stream into cup
      if(ff<.15){
        ctx.save(); ctx.globalAlpha=1-ff/.15;
        ctx.strokeStyle=col; ctx.lineWidth=6;
        ctx.beginPath(); ctx.moveTo(spX,my-22); ctx.lineTo(spX,my-2); ctx.stroke();
        ctx.restore();
      }
      // Metal in cup
      if(ff>.0){
        ctx.save(); ctx.globalAlpha=Math.min(sat(ff/.05),.95);
        ctx.fillStyle=col;
        ctx.beginPath();
        ctx.moveTo(spX-24,my-20); ctx.lineTo(spX+24,my-20);
        ctx.lineTo(spX+spW/2-1,my-1); ctx.lineTo(spX-spW/2+1,my-1);
        ctx.closePath(); ctx.fill();
        ctx.restore();
      }
      // Sprue fill top→bottom
      const spF=sat(ff/.20);
      if(spF>0){ ctx.fillStyle=col; ctx.fillRect(spX-spW/2,my,spW,hH*spF); }
      // Left runner left→right
      const rF=sat((ff-.18)/.18);
      if(rF>0){ ctx.fillStyle=col; ctx.fillRect(spX-spW/2,cy,(cvX-(spX-spW/2))*rF,runH); }
      // Cavity fill BOTTOM→TOP
      const cF=ease(sat((ff-.32)/.52));
      if(cF>0){ ctx.fillStyle=col; ctx.fillRect(cvX,cvTop+cvH*(1-cF),cvW,cvH*cF); }
      // Right runner
      const rrF=sat((ff-.78)/.14);
      if(rrF>0){ ctx.fillStyle=col; ctx.fillRect(cvX+cvW,cy,(rsX+rsW/2-(cvX+cvW))*rrF,runH); }
      // Riser fill bottom→top
      const risF=sat((ff-.88)/.12);
      if(risF>0){ ctx.fillStyle=col; ctx.fillRect(rsX-rsW/2,cy-hH*risF,rsW,hH*risF); }
    }

    // Fill-direction arrow
    if(t>.38&&t<.78){
      const fa=Math.min(sat((t-.38)/.08),1-sat((t-.72)/.06));
      ctx.save(); ctx.globalAlpha=fa;
      arrow(cx+cvW*.25,cvTop+cvH*.78,cx+cvW*.25,cvTop+cvH*.14,'#ffd060',1.5,8);
      ctx.restore();
    }

    lbl('Pouring cup',spX,my-32,{align:'center',color:'#aaa060',size:9});
    lbl('Sprue',spX+spW/2+4,my+hH*.35,{align:'left',color:'#6878a0',size:9});
    lbl('Runner',(spX-spW/2+cvX)/2,cy-18,{align:'center',color:'#6878a0',size:9});
    lbl('Cavity',cx,cy+cvH*.25,{align:'center',color:'rgba(100,120,160,.55)',size:9});
    lbl('Riser',rsX,my+hH*.28,{align:'center',color:'#6878a0',size:9});
    lbl('COPE',mx-6,my+hH*.5+4,{align:'right',color:'#7a6840',size:10});
    lbl('DRAG',mx-6,cy+hH*.5+4, {align:'right',color:'#7a6840',size:10});
  },
  // ── STEP 3 : Solidification & Shakeout ────────────
  s3(){
    const {cx,cy,mw,mh,mx,my,hH,cvW,cvH,cvX,cvTop,spW,spX,rsW,rsX,runH}=this._geom();
    const t=this.t;
    let stage;
    if(t<.22)      stage='Solidifying';
    else if(t<.45) stage='Removing cope';
    else if(t<.68) stage='Shakeout';
    else if(t<.80) stage='Casting complete';
    else if(t<.93) stage='Trimming gating system';
    else           stage='Finished casting';
    setStage(stage,'Sand Casting');

    const solid=sat(t/.22);
    const col=moltCol(solid);
    const copeRise=t>.22?easeO(sat((t-.22)/.23))*H*.24:0;
    const sandA=t>.45?Math.max(0,1-sat((t-.45)/.23)):1;

    // Trim-phase progress (0→1 over t=0.80–0.93)
    const trimP=t>.80?sat((t-.80)/.13):0;
    const trimA=1-trimP;          // gating opacity: 1→0 as pieces fly off
    const dist=trimP*90;          // travel distance in px (max 90)

    // DRAG (fades during shakeout)
    ctx.save(); ctx.globalAlpha=sandA;
    this._sand(mx,cy,mw,hH);
    ctx.fillStyle='#0d0f1a'; ctx.fillRect(cvX,cy,cvW,cvH/2);
    ctx.restore();

    // COPE (lifts then fades)
    ctx.save(); ctx.translate(0,-copeRise); ctx.globalAlpha=sandA;
    this._sand(mx,my,mw,hH);
    ctx.fillStyle='#0d0f1a';
    ctx.fillRect(cvX,cvTop,cvW,cvH/2);
    ctx.fillRect(spX-spW/2,my,spW,hH);
    ctx.fillRect(rsX-rsW/2,my,rsW,hH);
    ctx.restore();

    // METAL casting body (always visible)
    ctx.fillStyle=col;
    ctx.fillRect(cvX,cvTop,cvW,cvH);
    if(solid>.5){
      ctx.strokeStyle='#606880'; ctx.lineWidth=1;
      ctx.strokeRect(cvX,cvTop,cvW,cvH);
    }

    // GATING pieces — static until trim phase, then fly off at 45°
    if(trimA>0){
      ctx.fillStyle=col;
      // Sprue stub → NW (left + up)
      ctx.save(); ctx.translate(-dist,-dist); ctx.globalAlpha=trimA;
      ctx.fillRect(spX-spW/2,my+hH*.08,spW,hH*.92);
      ctx.restore();
      // Left runner → SW (left + down)
      ctx.save(); ctx.translate(-dist,+dist); ctx.globalAlpha=trimA;
      ctx.fillRect(spX-spW/2,cy,cvX-(spX-spW/2),runH);
      ctx.restore();
      // Riser stub → NE (right + up)
      ctx.save(); ctx.translate(+dist,-dist); ctx.globalAlpha=trimA;
      ctx.fillRect(rsX-rsW/2,my+hH*.08,rsW,hH*.92);
      ctx.restore();
      // Right runner → SE (right + down)
      ctx.save(); ctx.translate(+dist,+dist); ctx.globalAlpha=trimA;
      ctx.fillRect(cvX+cvW,cy,rsX+rsW/2-(cvX+cvW),runH);
      ctx.restore();
    }

    // Parting line + COPE/DRAG labels (while sand visible)
    ctx.save(); ctx.globalAlpha=sandA;
    ctx.setLineDash([5,4]); ctx.strokeStyle='rgba(120,140,180,.45)'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(mx,cy); ctx.lineTo(mx+mw,cy); ctx.stroke();
    ctx.setLineDash([]);
    lbl('COPE',mx-6,my+hH*.5+4,{align:'right',color:`rgba(122,104,64,${sandA})`,size:10});
    lbl('DRAG',mx-6,cy+hH*.5+4, {align:'right',color:`rgba(122,104,64,${sandA})`,size:10});
    ctx.restore();

    // Post-shakeout labels
    if(t>.68){
      const la=sat((t-.68)/.12);
      // "Casting" label — persists throughout
      ctx.save(); ctx.globalAlpha=la;
      lbl('Casting',cx,cy+4,{align:'center',color:'#a0b8d8',size:13,bold:true});
      ctx.restore();
      // Stub + hint labels — fade away with the gating pieces
      const stubA=la*trimA;
      if(stubA>0.01){
        ctx.save(); ctx.globalAlpha=stubA;
        lbl('Sprue stub',spX,my+hH*.5,    {align:'center',color:'#7080a0',size:9});
        lbl('Riser stub',rsX,my+hH*.5,    {align:'center',color:'#7080a0',size:9});
        lbl('← cut off after casting →',cx,cvTop+cvH+20,{align:'center',color:'#485868',size:9});
        ctx.restore();
      }
    }

    // Trimming comment — fades in then out during trim phase
    if(t>.80&&t<.93){
      const ta=Math.min(sat((t-.80)/.06), 1-sat((t-.87)/.06));
      ctx.save(); ctx.globalAlpha=ta;
      lbl('Removing sprue, runners & riser…',cx,cvTop-24,
          {align:'center',color:'#c09050',size:11,bold:true});
      ctx.restore();
    }

    // Finished casting label — fades in at the end
    if(t>=.93){
      const fa=sat((t-.93)/.07);
      ctx.save(); ctx.globalAlpha=fa;
      lbl('Finished casting — ready for post-processing',cx,cvTop-24,
          {align:'center',color:'#70d890',size:11,bold:true});
      ctx.restore();
    }
  },
  cleanup(){}
};

// ══════════════════════════════════════
//  CASTING — DIE CASTING
// ══════════════════════════════════════
const DieCasting = {
  meta:{name:'Die Casting',mat:'Zn, Al, Mg alloys',temp:'400–700 °C',cat:'Casting'},
  t:0, period:7,
  init(){ this.t=0; },
  onResize(){},
  step(dt){ this.t=(this.t+dt/this.period)%1; },
  draw(){
    grid();
    const cx=W/2, cy=H/2, t=this.t;
    let phase, stageName;
    if(t<.08){phase=0;stageName='Dies open';}
    else if(t<.22){phase=1;stageName='Dies closing';}
    else if(t<.55){phase=2;stageName='Injection';}
    else if(t<.72){phase=3;stageName='Solidifying';}
    else if(t<.88){phase=4;stageName='Dies opening';}
    else{phase=5;stageName='Part ejected';}
    setStage(stageName,'Die Casting');

    const dw=Math.min(W*.22,140), dh=Math.min(H*.54,260);
    // Gap between die halves
    const openGap=(phase<=1)?lerp(W*.10,2,ease(sat((t-.08)/.14))):
                 (phase>=4)?lerp(2,W*.10,ease(sat((t-.72)/.16))):2;
    const lx=cx-dw-openGap, rx=cx+openGap;

    // Left die
    ctx.fillStyle='#2d3d58'; rrect(lx,cy-dh/2,dw,dh,5); ctx.fill();
    hatch(lx,cy-dh/2,dw,dh,10,'rgba(255,255,255,.05)');
    ctx.strokeStyle='#4a6088'; ctx.lineWidth=2; rrect(lx,cy-dh/2,dw,dh,5); ctx.stroke();

    // Right die
    ctx.fillStyle='#2d3d58'; rrect(rx,cy-dh/2,dw,dh,5); ctx.fill();
    hatch(rx,cy-dh/2,dw,dh,10,'rgba(255,255,255,.05)');
    ctx.strokeStyle='#4a6088'; ctx.lineWidth=2; rrect(rx,cy-dh/2,dw,dh,5); ctx.stroke();

    // Cavity (carved into die faces)
    const cvW=openGap+2, cvH=dh*.45;
    const cvX=lx+dw-.5, cvY=cy-cvH/2;
    if(openGap<20){
      ctx.fillStyle='#0d0f1a'; ctx.fillRect(cvX,cvY,cvW,cvH);
    }

    // Injection shot sleeve on right side
    const slW=W*.12, slH=dh*.12;
    const slX=rx+dw, slY=cy-slH/2;
    ctx.fillStyle='#1e2a40'; rrect(slX,slY,slW,slH,3); ctx.fill();
    ctx.strokeStyle='#3a5080'; ctx.lineWidth=1.5; rrect(slX,slY,slW,slH,3); ctx.stroke();
    // Plunger
    const plungAdv=(phase>=2)?ease(sat((t-.22)/.20)):0;
    const plX=slX+slW-slW*.2-slW*.6*plungAdv;
    ctx.fillStyle='#5a7aaa'; ctx.fillRect(plX,slY+2,slW*.2,slH-4);

    // Gate from sleeve to cavity
    const gateW=openGap+2, gateH=slH*.5;
    if(openGap<20){
      ctx.fillStyle='#0d0f1a'; ctx.fillRect(cvX,cy-gateH/2,gateW,gateH);
    }

    // Molten metal in cavity
    if(phase>=2 && openGap<20){
      const ff=ease(sat((t-.22)/.25));
      const solid=phase>=3?sat((t-.55)/.17):0;
      const col=moltCol(solid);
      ctx.fillStyle=col; ctx.fillRect(cvX,cvY+cvH*(1-ff),cvW,cvH*ff);
      // Also fill gate
      ctx.fillStyle=col; ctx.fillRect(rx,cy-gateH/2,openGap+2,gateH);
    }

    // Ejection pins + part
    if(phase>=5){
      const a=sat((t-.88)/.08);
      ctx.fillStyle=`rgba(140,160,180,${a})`;
      ctx.fillRect(cx-cvW*.4,cy-cvH/2,cvW*.8,cvH);
      // Ejector pins pushing right
      for(let py=0;py<3;py++){
        const pinY=cvY+cvH*.2+py*cvH*.3;
        ctx.fillStyle=`rgba(170,190,220,${a})`;
        ctx.fillRect(lx+dw,pinY,8,4);
      }
    }

    // ── LABELS ──
    lbl('Fixed Die', lx+dw*.5, cy-dh/2-12,{align:'center',color:'#5a7090',size:10});
    lbl('Moving Die',rx+dw*.5, cy-dh/2-12,{align:'center',color:'#5a7090',size:10});
    lbl('Shot Sleeve',slX+slW*.5,slY-10,{align:'center',color:'#5a7090',size:10});
    lbl('Plunger',plX,slY+slH+14,{align:'center',color:'#6878a0',size:10});
    if(openGap<30) lbl('Cavity',cx,cy+cvH/2+16,{align:'center',color:'#6878a0',size:10});
    // closing arrow
    if(phase===1){
      arrow(rx+dw*.3,cy,rx+2,cy,'#ffc040',2,8);
      arrow(lx+dw*.7,cy,lx+dw-2,cy,'#ffc040',2,8);
    }
  },
  cleanup(){}
};

// ══════════════════════════════════════
//  CASTING — INVESTMENT CASTING
// ══════════════════════════════════════
const InvestmentCasting = {
  meta:{name:'Investment Casting',mat:'Metals, Superalloys',temp:'1000–1700 °C',cat:'Casting'},
  steps:[
    {label:'Wax Pattern Tree', period:10},
    {label:'Shell Building',   period:12},
    {label:'Dewaxing',         period:9},
    {label:'Pouring',          period:10},
    {label:'Breakout',         period:11},
  ],
  currentStep:0, t:0,
  init(){ this.t=0; },
  onResize(){},
  step(dt){ this.t=(this.t+dt/(this.steps[this.currentStep]?.period||9))%1; },
  draw(){
    grid();
    switch(this.currentStep){
      case 0:this.s0();break;
      case 1:this.s1();break;
      case 2:this.s2();break;
      case 3:this.s3();break;
      default:this.s4();break;
    }
  },
  _geom(){
    const cx=W/2;
    const spW=14, spH=Math.min(H*.66,360);
    const spTop=H*.13, spBot=spTop+spH;
    const cupW=58, cupH=20, cupTop=spTop-cupH;
    const pW=38, pH=52, runLen=26, runH=9, sT=12;
    const parts=[
      {side:-1, yF:0.12}, {side: 1, yF:0.27},
      {side:-1, yF:0.44}, {side: 1, yF:0.59},
      {side:-1, yF:0.74}, {side: 1, yF:0.89},
    ];
    return {cx,spW,spH,spTop,spBot,cupW,cupH,cupTop,pW,pH,runLen,runH,sT,parts};
  },
  // Draw entire tree with optional expansion e (used for ceramic shell)
  _tree(col, e=0){
    const {cx,spW,spH,spTop,cupW,cupH,cupTop,pW,pH,runLen,runH,parts}=this._geom();
    ctx.fillStyle=col;
    ctx.beginPath();
    ctx.moveTo(cx-cupW/2-e,cupTop-e);   ctx.lineTo(cx+cupW/2+e,cupTop-e);
    ctx.lineTo(cx+spW/2+e, cupTop+cupH+e); ctx.lineTo(cx-spW/2-e,cupTop+cupH+e);
    ctx.closePath(); ctx.fill();
    ctx.fillRect(cx-spW/2-e, spTop, spW+e*2, spH+e);
    parts.forEach(p=>{
      const py=spTop+p.yF*spH;
      if(p.side===-1){
        ctx.fillRect(cx-spW/2-runLen-e, py-runH/2-e, runLen+e, runH+e*2);
        ctx.fillRect(cx-spW/2-runLen-pW-e, py-pH/2-e, pW+e*2, pH+e*2);
      } else {
        ctx.fillRect(cx+spW/2, py-runH/2-e, runLen+e, runH+e*2);
        ctx.fillRect(cx+spW/2+runLen, py-pH/2-e, pW+e*2, pH+e*2);
      }
    });
  },

  // ── STEP 0 : Wax Pattern Tree ────────────────────────
  s0(){
    const {cx,spW,spH,spTop,spBot,cupW,cupH,cupTop,pW,pH,runLen,runH,parts}=this._geom();
    const t=this.t;
    setStage(t<.82?'Assembling wax tree':'Wax tree complete','Investment Casting');

    // Central sprue + cup appear first
    const spA=ease(sat(t/.07));
    ctx.save(); ctx.globalAlpha=spA; ctx.fillStyle='#d8c44a';
    ctx.fillRect(cx-spW/2,spTop,spW,spH);
    ctx.beginPath();
    ctx.moveTo(cx-cupW/2,cupTop); ctx.lineTo(cx+cupW/2,cupTop);
    ctx.lineTo(cx+spW/2,cupTop+cupH); ctx.lineTo(cx-spW/2,cupTop+cupH);
    ctx.closePath(); ctx.fill();
    ctx.restore();

    // Each wax pattern slides outward from sprue, one by one
    parts.forEach((p,i)=>{
      const slideP=ease(sat((t-0.08-i*0.12)/0.09));
      if(slideP<=0) return;
      const rW=runLen*slideP;
      const py=spTop+p.yF*spH;
      ctx.save(); ctx.globalAlpha=Math.min(1,slideP*3);
      ctx.fillStyle='#d8c44a';
      if(p.side===-1){
        ctx.fillRect(cx-spW/2-rW, py-runH/2, rW, runH);
        ctx.fillRect(cx-spW/2-rW-pW, py-pH/2, pW, pH);
      } else {
        ctx.fillRect(cx+spW/2, py-runH/2, rW, runH);
        ctx.fillRect(cx+spW/2+rW, py-pH/2, pW, pH);
      }
      ctx.restore();
    });

    if(t>.82){
      const la=ease(sat((t-.82)/.12));
      ctx.save(); ctx.globalAlpha=la;
      lbl('Wax pattern tree',cx,cupTop-14,{align:'center',color:'#d4b830',size:11,bold:true});
      lbl('6 wax patterns on central sprue',cx,spBot+16,{align:'center',color:'#8a7820',size:9});
      ctx.restore();
    }
  },

  // ── STEP 1 : Shell Building ───────────────────────────
  s1(){
    const {cx,spW,spH,spTop,spBot,cupW,cupH,cupTop,pW,pH,runLen,sT,parts}=this._geom();
    const t=this.t;
    const numCoats=6;
    const ci=Math.min(numCoats-1,Math.floor(t/(0.78/numCoats)));
    const cf=(t/(0.78/numCoats))-ci;
    const dipP=t<0.78?Math.sin(cf*Math.PI):0;
    const dipAmt=dipP*38;
    const shellT=t<0.78?(ci+cf*0.9)/numCoats*sT:sT;
    setStage(t<0.78?`Dip coat ${ci+1} of ${numCoats}`:'Ceramic shell drying','Investment Casting');

    // Slurry vat at bottom
    if(t<0.82){
      const vA=t<0.78?1:Math.max(0,1-sat((t-0.78)/0.04));
      ctx.save(); ctx.globalAlpha=vA*0.7;
      ctx.fillStyle='#1a304a';
      ctx.fillRect(0,spBot+20+dipAmt,W,H);
      ctx.strokeStyle='rgba(60,100,150,.7)'; ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(0,spBot+20+dipAmt); ctx.lineTo(W,spBot+20+dipAmt); ctx.stroke();
      lbl('Ceramic slurry vat',cx,spBot+34+dipAmt,{align:'center',color:'#3a5878',size:9});
      ctx.restore();
    }

    // Tree dips with dipAmt offset
    ctx.save(); ctx.translate(0,dipAmt);
    if(shellT>0.5) this._tree('#5a6272',shellT);
    this._tree('#d8c44a',0);
    ctx.restore();

    if(t<0.78){
      lbl(`Coat ${ci+1} / ${numCoats}`,cx,cupTop+dipAmt-14,
          {align:'center',color:'rgba(200,220,255,.55)',size:10,bold:true});
    } else {
      const fa=ease(sat((t-0.78)/0.22));
      ctx.save(); ctx.globalAlpha=fa;
      lbl('Ceramic shell complete',cx,cupTop-14,{align:'center',color:'#a0c0e0',size:11,bold:true});
      lbl(`${numCoats} coats — ~${sT} mm thick`,cx,spBot+18,{align:'center',color:'#5a7090',size:9});
      ctx.restore();
    }
  },

  // ── STEP 2 : Dewaxing ────────────────────────────────
  s2(){
    const {cx,spW,spH,spTop,spBot,cupW,cupH,cupTop,pW,runLen,sT,parts}=this._geom();
    const t=this.t;
    const waxDrain=t>.20?ease(sat((t-.20)/.50)):0;
    setStage(
      t<.20?'Autoclave heating':t<.70?'Wax melting & draining':t<.88?'Flash firing':'Hollow shell ready',
      'Investment Casting'
    );

    // Furnace glow
    if(t<.88){
      const gA=sat(t/.15)*Math.max(0,1-sat((t-.80)/.08));
      if(gA>0){
        const g=ctx.createRadialGradient(cx,H*.5,0,cx,H*.5,(pW+runLen+spW)*2);
        g.addColorStop(0,`rgba(255,120,20,${gA*.35})`);
        g.addColorStop(1,'rgba(255,60,0,0)');
        ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
      }
    }

    // Grey shell, dark interior, wax fading out
    this._tree('#5a6272',sT);
    this._tree('#0d0f1a',0);
    if(waxDrain<0.99){
      ctx.save(); ctx.globalAlpha=Math.max(0,1-waxDrain);
      this._tree('#d4b830',0);
      ctx.restore();
    }

    // Wax drips below shell
    if(waxDrain>0.05&&waxDrain<0.92){
      const dBase=spBot+sT+4;
      ctx.fillStyle='rgba(196,168,32,.72)';
      for(let i=0;i<4;i++){
        ctx.beginPath();
        ctx.arc(cx+(i-1.5)*10, dBase+waxDrain*24+i*9, 2.5, 0, Math.PI*2);
        ctx.fill();
      }
      if(waxDrain>0.2)
        lbl('Wax drains via gravity',cx,dBase+waxDrain*24+30,
            {align:'center',color:'#7a6820',size:9});
    }

    if(t>.88){
      const fa=ease(sat((t-.88)/.12));
      ctx.save(); ctx.globalAlpha=fa;
      lbl('Hollow ceramic mold',cx,cupTop-14,{align:'center',color:'#80a0c8',size:11,bold:true});
      lbl('Tree-shaped cavity — ready for metal',cx,spBot+sT+18,
          {align:'center',color:'#4a6888',size:9});
      ctx.restore();
    }
  },

  // ── STEP 3 : Pouring ─────────────────────────────────
  s3(){
    const {cx,spW,spH,spTop,spBot,cupW,cupH,cupTop,pW,pH,runLen,runH,sT,parts}=this._geom();
    const t=this.t;
    const solid=t>.90?sat((t-.90)/.10):0;
    const col=moltCol(solid);
    const ff=t>.10?ease(sat((t-.10)/.80)):0;
    setStage(
      t<.10?'Preheated shell ready':t<.92?'Pouring molten metal':'Solidifying',
      'Investment Casting'
    );

    // Shell + dark interior
    this._tree('#5a6272',sT);
    this._tree('#0d0f1a',0);

    // Pouring cup overlay
    ctx.fillStyle='#2a3550';
    ctx.beginPath();
    ctx.moveTo(cx-cupW/2,cupTop); ctx.lineTo(cx+cupW/2,cupTop);
    ctx.lineTo(cx+spW/2,cupTop+cupH); ctx.lineTo(cx-spW/2,cupTop+cupH);
    ctx.closePath(); ctx.fill();
    ctx.strokeStyle='#4a5878'; ctx.lineWidth=1; ctx.stroke();

    // Metal fill
    if(ff>0){
      ctx.fillStyle=col;
      // Sprue fills top-to-bottom
      const spF=sat(ff/.30);
      if(spF>0) ctx.fillRect(cx-spW/2,spTop,spW,spH*spF);
      // Each part fills as metal level descends to its runner junction
      parts.forEach(p=>{
        const py=spTop+p.yF*spH;
        const jF=p.yF*.40;
        const runF=sat((ff-jF)/.10);
        const partF=sat((ff-jF-.10)/.25);
        if(p.side===-1){
          if(runF>0) ctx.fillRect(cx-spW/2-runLen*runF, py-runH/2, runLen*runF, runH);
          if(partF>0) ctx.fillRect(cx-spW/2-runLen-pW, py+pH/2-pH*partF, pW, pH*partF);
        } else {
          if(runF>0) ctx.fillRect(cx+spW/2, py-runH/2, runLen*runF, runH);
          if(partF>0) ctx.fillRect(cx+spW/2+runLen, py+pH/2-pH*partF, pW, pH*partF);
        }
      });
    }

    // Molten stream from cup
    if(t>.06&&t<.88){
      const sa=Math.min(sat((t-.06)/.07), 1-sat((t-.82)/.06));
      ctx.save(); ctx.globalAlpha=sa;
      ctx.fillStyle='#ff9040';
      ctx.fillRect(cx-3,cupTop+cupH,6,spTop-(cupTop+cupH)+3);
      ctx.fillStyle='#ff8020';
      ctx.fillRect(cx-cupW/2+3,cupTop+3,cupW-6,cupH-5);
      ctx.restore();
    }

    lbl('Pouring cup',cx,cupTop-12,{align:'center',color:'#6878a0',size:9});
    if(solid>.2){
      const fa=sat((solid-.2)/.8);
      ctx.save(); ctx.globalAlpha=fa;
      lbl('Solidifying…',cx,spBot+sT+18,{align:'center',color:'#8090c0',size:10,bold:true});
      ctx.restore();
    }
  },

  // ── STEP 4 : Breakout ────────────────────────────────
  s4(){
    const {cx,spW,spH,spTop,spBot,cupW,cupH,cupTop,pW,pH,runLen,runH,sT,parts}=this._geom();
    const t=this.t;
    const breakP=ease(sat(t/.38));
    const shellA=Math.max(0,1-breakP);
    setStage(
      t<.38?'Breaking ceramic shell':t<.72?'Metal tree revealed':'Finished castings',
      'Investment Casting'
    );
    const col=moltCol(1);

    // Ceramic shell fragments scatter radially
    if(shellA>0.01){
      const midY=(spTop+spBot)/2;
      const numFrag=14;
      for(let i=0;i<numFrag;i++){
        const ang=i/numFrag*Math.PI*2;
        const rx=pW+runLen+spW/2+sT+6, ry=spH/2+sT+6;
        const dist=breakP*85;
        ctx.save();
        ctx.translate(cx+Math.cos(ang)*rx+Math.cos(ang)*dist,
                      midY+Math.sin(ang)*ry+Math.sin(ang)*dist);
        ctx.rotate(breakP*ang*2.5);
        ctx.globalAlpha=shellA*.88; ctx.fillStyle='#5a6272';
        ctx.fillRect(-sT*.8,-sT*.65,sT*1.6,sT*1.3);
        ctx.restore();
      }
    }

    // Metal tree fades in as shell breaks
    ctx.save(); ctx.globalAlpha=ease(breakP);
    this._tree(col,0);
    ctx.restore();

    if(t>.38){
      const la=ease(sat((t-.38)/.16));
      ctx.save(); ctx.globalAlpha=la;
      lbl('Metal casting tree',cx,cupTop-14,{align:'center',color:'#a0b8d8',size:11,bold:true});
      lbl('6 investment castings on sprue',cx,spBot+16,{align:'center',color:'#6878a0',size:9});
      ctx.restore();
    }
    if(t>.72){
      const fa=ease(sat((t-.72)/.20));
      ctx.save(); ctx.globalAlpha=fa;
      lbl('Near-net shape — minimal machining required',cx,spBot+sT+34,
          {align:'center',color:'#70d890',size:10,bold:true});
      ctx.restore();
    }
  },
  cleanup(){}
};

// ══════════════════════════════════════
//  FORMING — ROLLING
// ══════════════════════════════════════
const Rolling = {
  meta:{name:'Rolling',mat:'Metals, Polymers',temp:'Cold–1200 °C',cat:'Forming'},
  t:0, period:4,
  init(){ this.t=0; },
  onResize(){},
  step(dt){ this.t=(this.t+dt/this.period)%1; },
  draw(){
    grid();
    const cx=W/2, cy=H/2, t=this.t;
    setStage('Under compression','Rolling');

    const rollerR=Math.min(H*.2,100);
    const gap=Math.min(H*.035,18);
    const topY=cy-rollerR-gap/2, botY=cy+rollerR+gap/2;

    // Workpiece travelling left-to-right
    // t=0: left of rollers, t=0.5: through rollers, t=1: right of rollers
    const pos=t; // 0→1
    const inRollers=pos>0.2 && pos<0.8;
    const bW=W*.45;
    const thickIn=H*.072, thickOut=H*.042;

    // Compute current thickness at cross-section
    const cx_piece=lerp(-bW*.6, bW*.6+W, pos); // position of piece center
    const pieceLeft=cx_piece-bW/2, pieceRight=cx_piece+bW/2;

    // Roller axis positions (fixed)
    const lRoller=cx-W*.05, rRoller=cx+W*.05; // start/end of roll zone

    // Draw workpiece (tapered shape):
    // Left of rollers: full thick; in rollers: reducing; right: reduced
    ctx.save();
    const entryX=cx-rollerR*.7, exitX=cx+rollerR*.7;
    ctx.fillStyle='#5b8ab5';
    ctx.strokeStyle='#3a6080'; ctx.lineWidth=2;
    ctx.beginPath();
    // We draw a polygon that is thick on the left, transitions in middle
    const pl=pieceLeft, pr=pieceRight;
    const segLen=exitX-entryX;

    function pieceY(x){
      if(x<entryX) return thickIn/2;
      if(x>exitX)  return thickOut/2;
      return lerp(thickIn/2, thickOut/2, (x-entryX)/segLen);
    }
    const steps=40;
    ctx.beginPath();
    for(let i=0;i<=steps;i++){
      const x=pl+i/steps*(pr-pl);
      const hh=pieceY(x);
      if(i===0) ctx.moveTo(x, cy-hh);
      else       ctx.lineTo(x, cy-hh);
    }
    for(let i=steps;i>=0;i--){
      const x=pl+i/steps*(pr-pl);
      const hh=pieceY(x);
      ctx.lineTo(x, cy+hh);
    }
    ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.restore();

    // ── ROLLERS ──
    function drawRoller(ry,dir){
      const grd=ctx.createRadialGradient(cx-rollerR*.2,ry-rollerR*.2,rollerR*.1,cx,ry,rollerR);
      grd.addColorStop(0,'#4a5a70'); grd.addColorStop(1,'#1e2838');
      ctx.beginPath(); ctx.arc(cx,ry,rollerR,0,Math.PI*2);
      ctx.fillStyle=grd; ctx.fill();
      ctx.strokeStyle='#5a7090'; ctx.lineWidth=2; ctx.stroke();
      spinMark(cx,ry,rollerR,t*dir,'rgba(200,220,255,.35)');
      // Roller shaft stubs
      ctx.fillStyle='#3a4a60';
      ctx.fillRect(cx+rollerR, ry-6, 20, 12);
      ctx.fillRect(cx-rollerR-20, ry-6, 20, 12);
    }
    drawRoller(topY, 1);
    drawRoller(botY,-1);

    // Force arrows
    arrow(cx-W*.22, topY-rollerR*.5, cx-W*.22, topY+rollerR*.3,'#ff6060',2,8);
    arrow(cx-W*.22, botY+rollerR*.5, cx-W*.22, botY-rollerR*.3,'#ff6060',2,8);

    // ── LABELS ──
    lbl('Rolls', cx+rollerR+28, cy,{align:'left',color:'#5a7090',size:11});
    lbl('↑ Reduction',cx-W*.22-6, topY-rollerR*.6,{align:'right',color:'#ff6060',size:10});
    const redPct=Math.round((1-thickOut/thickIn)*100);
    lbl(`${redPct}% thickness reduction`,cx,H-22,{color:'#8090b4',size:11});
    lbl('Entry →', lerp(pl,cx-.5,0.3), cy-thickIn/2-12,{color:'#8090b4',size:10});
    lbl('→ Exit',  lerp(cx+.5,pr,0.7), cy-thickOut/2-12,{color:'#8090b4',size:10});
  },
  cleanup(){}
};

// ══════════════════════════════════════
//  FORMING — FORGING
// ══════════════════════════════════════
const Forging = {
  meta:{name:'Forging',mat:'Metals, Superalloys',temp:'700–1300 °C',cat:'Forming'},
  t:0, period:5,
  init(){ this.t=0; },
  onResize(){},
  step(dt){ this.t=(this.t+dt/this.period)%1; },
  draw(){
    grid();
    const cx=W/2, cy=H/2, t=this.t;
    let stageName;
    let press;
    if(t<.15){press=0; stageName='Billet placed';}
    else if(t<.50){press=ease(sat((t-.15)/.35)); stageName='Die closing';}
    else if(t<.65){press=1; stageName='Full compression';}
    else if(t<.85){press=1-ease(sat((t-.65)/.20)); stageName='Die opening';}
    else{press=0; stageName='Part removed';}
    setStage(stageName,'Forging');

    const dW=Math.min(W*.55,320), dH=Math.min(H*.14,55);
    const clearance=Math.min(H*.22,90);
    // Die positions unchanged from original (same visual travel)
    const topY=cy-clearance*(1-press)-dH;
    const botY=cy+clearance*(1-press);

    const bW0=dW*.42, bH0=Math.min(H*.18,75);
    // Contact when die face reaches billet: clearance*(1-pressContact) = bH0/2
    const pressContact=Math.max(0, 1-bH0/(2*clearance));
    const touching=press>=pressContact;
    // Map post-contact press onto 0→1 so compression only begins at contact
    const effectivePress=touching ? sat((press-pressContact)/(1-pressContact)) : 0;
    // Original compression formula, now gated behind contact
    const bH=bH0*(1-effectivePress*.62);
    const bW=bW0*(bH0/bH);
    const bR=Math.min(bW,bH)*.15;
    const bX=cx-bW/2, bY=cy-bH/2;

    // ── DIES ──
    const dieGrad=(x,y,w,h)=>{
      const g=ctx.createLinearGradient(x,y,x,y+h);
      g.addColorStop(0,'#3a4a65'); g.addColorStop(1,'#1e2838'); return g;
    };
    // Top die
    ctx.fillStyle=dieGrad(cx-dW/2,topY,dW,dH);
    rrect(cx-dW/2,topY,dW,dH,4); ctx.fill();
    ctx.strokeStyle='#5a7090'; ctx.lineWidth=2;
    rrect(cx-dW/2,topY,dW,dH,4); ctx.stroke();
    // Bottom die
    ctx.fillStyle=dieGrad(cx-dW/2,botY,dW,dH);
    rrect(cx-dW/2,botY,dW,dH,4); ctx.fill();
    ctx.strokeStyle='#5a7090'; ctx.lineWidth=2;
    rrect(cx-dW/2,botY,dW,dH,4); ctx.stroke();

    // ── BILLET ──
    const hot=Math.min(1,(t-.10)/.25)*0.8;
    ctx.fillStyle=hot>0?`rgb(${lerp(90,255,hot)|0},${lerp(140,140,hot)|0},${lerp(180,0,hot)|0})`:'#5b8ab5';
    rrect(bX,bY,bW,bH,bR); ctx.fill();
    ctx.strokeStyle='rgba(80,120,160,.7)'; ctx.lineWidth=1.5;
    rrect(bX,bY,bW,bH,bR); ctx.stroke();

    // Flash (thin fin at die parting line) — only after die makes contact
    if(touching && effectivePress>.3){
      const fl=effectivePress-.3, flashW=fl*dW*.26, flashH=Math.max(2,bH*.12);
      ctx.fillStyle=moltCol(.3);
      ctx.fillRect(cx-bW/2-flashW, cy-flashH/2, flashW, flashH);
      ctx.fillRect(cx+bW/2,        cy-flashH/2, flashW, flashH);
    }

    // Force arrows
    if(press>0){
      const fLen=H*.12*press;
      arrow(cx,topY-fLen,cx,topY,'#ff6060',2.5,10);
      arrow(cx,botY+fLen,cx,botY,'#ff6060',2.5,10);
    }

    // ── LABELS ──
    lbl('Top Die',   cx-dW/2-8, topY+dH/2+4,{align:'right',color:'#5a7090',size:10});
    lbl('Bottom Die',cx-dW/2-8, botY+dH/2+4,{align:'right',color:'#5a7090',size:10});
    lbl('Billet',    cx,         bY-12,       {align:'center',color:'#8090b4',size:11});
    if(touching && effectivePress>.45) lbl('Flash',cx+bW/2+28,cy,{align:'left',color:'#8090b4',size:10});
  },
  cleanup(){}
};

// ══════════════════════════════════════
//  FORMING — EXTRUSION
// ══════════════════════════════════════
const Extrusion = {
  meta:{name:'Extrusion',mat:'Metals, Polymers',temp:'150–1300 °C',cat:'Forming'},
  t:0, period:6,
  init(){ this.t=0; },
  onResize(){},
  step(dt){ this.t=(this.t+dt/this.period)%1; },
  draw(){
    grid();
    const cx=W/2, cy=H/2, t=this.t;
    const advance=ease(sat((t-.05)/.75));
    let stageName=(t<.05)?'Billet loaded':(t<.80)?'Extrusion':'Reset';
    setStage(stageName,'Extrusion');

    const ctnW=Math.min(W*.50,280), ctnH=Math.min(H*.20,80);
    const ctnX=cx-ctnW*.25, ctnY=cy-ctnH/2;

    // Die block on left
    const dieW=Math.min(W*.07,36), dieH=ctnH*1.4;
    const dieX=ctnX-dieW, dieY=cy-dieH/2;
    ctx.fillStyle='#2d3d58'; rrect(dieX,dieY,dieW,dieH,3); ctx.fill();
    ctx.strokeStyle='#4a6088'; ctx.lineWidth=2; rrect(dieX,dieY,dieW,dieH,3); ctx.stroke();
    // Die opening
    const dieOpenH=ctnH*.32;
    ctx.fillStyle='#0d0f1a'; ctx.fillRect(dieX,cy-dieOpenH/2,dieW+1,dieOpenH);

    // Container
    ctx.fillStyle='#2d3d58'; rrect(ctnX,ctnY,ctnW,ctnH,3); ctx.fill();
    hatch(ctnX,ctnY,ctnW,ctnH,10,'rgba(255,255,255,.05)');
    ctx.strokeStyle='#4a6088'; ctx.lineWidth=2; rrect(ctnX,ctnY,ctnW,ctnH,3); ctx.stroke();
    // Container bore
    ctx.fillStyle='#0d0f1a'; ctx.fillRect(ctnX+1,ctnY+ctnH*.12,ctnW-2,ctnH*.76);

    // Billet inside
    const billetRemain=1-advance;
    ctx.fillStyle=moltCol(.15);
    ctx.fillRect(ctnX+ctnW*(1-billetRemain)+2, ctnY+ctnH*.12, ctnW*billetRemain-4, ctnH*.76);

    // Ram (comes from right)
    const ramW=ctnW*.22;
    const ramX=ctnX+ctnW+ramW*(1-advance)*1.1 - ramW*1.1 + ctnW*advance*.85;
    ctx.fillStyle='#3a5070'; rrect(ramX,ctnY+ctnH*.08,ramW,ctnH*.84,3); ctx.fill();
    ctx.strokeStyle='#5a78a0'; ctx.lineWidth=1.5; rrect(ramX,ctnY+ctnH*.08,ramW,ctnH*.84,3); ctx.stroke();
    // Ram rod
    ctx.fillStyle='#2a3a50';
    ctx.fillRect(ramX+ramW,cy-ctnH*.10,W*.15,ctnH*.20);

    // Extrudate (grows from die)
    const extLen=advance * Math.min(W*.35,180);
    if(extLen>1){
      ctx.fillStyle='#7aaccc';
      ctx.fillRect(dieX-extLen, cy-dieOpenH/2, extLen, dieOpenH);
      ctx.strokeStyle='#4a7a9a'; ctx.lineWidth=1.5;
      ctx.strokeRect(dieX-extLen, cy-dieOpenH/2, extLen, dieOpenH);
    }

    // Ram motion arrow
    if(advance<.9){
      arrow(ramX+ramW*.5+W*.04, cy, ramX+ramW*.5, cy, '#ffc040',2,8);
    }

    // ── LABELS ──
    lbl('Container', ctnX+ctnW*.5, ctnY-12,{align:'center',color:'#5a7090',size:10});
    lbl('Ram',       ramX+ramW*.5, ctnY+ctnH+16,{align:'center',color:'#6878a0',size:10});
    lbl('Die',       dieX+dieW*.5, dieY-12,{align:'center',color:'#5a7090',size:10});
    if(extLen>20) lbl('Extrudate', dieX-extLen*.5, cy-dieOpenH/2-12,{align:'center',color:'#7aaccc',size:10});
    // die opening cross-section marker
    ctx.setLineDash([3,3]); ctx.strokeStyle='rgba(100,140,180,.4)'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(dieX-2,cy-dieOpenH/2); ctx.lineTo(dieX-12,cy-dieOpenH/2);
    ctx.moveTo(dieX-2,cy+dieOpenH/2); ctx.lineTo(dieX-12,cy+dieOpenH/2); ctx.stroke();
    ctx.setLineDash([]);
  },
  cleanup(){}
};

// ══════════════════════════════════════
//  MOLDING — INJECTION MOLDING
// ══════════════════════════════════════
const InjectionMolding = {
  meta:{name:'Injection Molding',mat:'Thermoplastics, Thermosets',temp:'180–320 °C',cat:'Molding'},
  t:0, period:9,
  init(){ this.t=0; },
  onResize(){},
  step(dt){ this.t=(this.t+dt/this.period)%1; },
  draw(){
    grid();
    const cx=W/2, cy=H/2, t=this.t;
    let phase, stageName;
    if(t<.10){phase=0;stageName='Mold closed';}
    else if(t<.38){phase=1;stageName='Injection';}
    else if(t<.58){phase=2;stageName='Packing / cooling';}
    else if(t<.72){phase=3;stageName='Mold opening';}
    else if(t<.88){phase=4;stageName='Ejection';}
    else{phase=5;stageName='Mold closing';}
    setStage(stageName,'Injection Molding');

    // Barrel on left side
    const barH=Math.min(H*.14,58), barW=Math.min(W*.38,210);
    const barX=Math.min(W*.05,30), barY=cy-barH/2;

    ctx.fillStyle='#2d3d58'; rrect(barX,barY,barW,barH,3); ctx.fill();
    hatch(barX,barY,barW,barH,8,'rgba(255,255,255,.06)');
    ctx.strokeStyle='#4a6088'; ctx.lineWidth=2; rrect(barX,barY,barW,barH,3); ctx.stroke();
    // Barrel bore
    ctx.fillStyle='rgba(80,40,10,.7)';
    ctx.fillRect(barX+barW*.05,barY+barH*.14,barW*.9,barH*.72);

    // Heater bands (orange glows)
    for(let i=0;i<4;i++){
      const hx=barX+barW*.15+i*barW*.18;
      const grd=ctx.createLinearGradient(hx,barY,hx,barY+barH);
      grd.addColorStop(0,'rgba(255,120,0,.0)');
      grd.addColorStop(.5,'rgba(255,120,0,.18)');
      grd.addColorStop(1,'rgba(255,120,0,.0)');
      ctx.fillStyle=grd; ctx.fillRect(hx,barY,barW*.08,barH);
    }

    // Screw
    const screwAdv=(phase>=1&&phase<=2)?ease(sat((t-.10)/.15))*.35:0;
    for(let i=0;i<16;i++){
      const sx=barX+barW*.06+i*barW*.055+screwAdv*barW*.3;
      if(sx>barX+barW*.95) break;
      ctx.strokeStyle='rgba(140,180,220,.5)'; ctx.lineWidth=1;
      ctx.beginPath();
      ctx.moveTo(sx,barY+barH*.15); ctx.lineTo(sx-barW*.03,barY+barH*.85); ctx.stroke();
    }

    // Hopper
    const hopX=barX+barW*.8, hopW=barW*.14;
    ctx.strokeStyle='#4a6088'; ctx.lineWidth=2; ctx.fillStyle='#1e2838';
    ctx.beginPath();
    ctx.moveTo(hopX,barY); ctx.lineTo(hopX-hopW*.5,barY-barH*.9);
    ctx.lineTo(hopX+hopW*.5,barY-barH*.9); ctx.closePath();
    ctx.fill(); ctx.stroke();
    // Pellets in hopper
    for(let i=0;i<6;i++){
      const px=hopX-hopW*.3+i%3*hopW*.3+(i>2?hopW*.15:0);
      const py=barY-barH*.5-(i>2?barH*.25:0);
      ctx.beginPath(); ctx.arc(px,py,3,0,Math.PI*2);
      ctx.fillStyle='#44aa66'; ctx.fill();
    }

    // Nozzle
    ctx.fillStyle='#3a5070'; ctx.beginPath();
    ctx.moveTo(barX+barW,barY+barH*.15);
    ctx.lineTo(barX+barW+barW*.04,barY+barH*.35);
    ctx.lineTo(barX+barW+barW*.04,barY+barH*.65);
    ctx.lineTo(barX+barW,barY+barH*.85);
    ctx.closePath(); ctx.fill();
    ctx.strokeStyle='#5a7090'; ctx.lineWidth=1.5; ctx.stroke();

    // ── MOLD HALVES ──
    const moldW=Math.min(W*.18,100), moldH=Math.min(H*.58,260);
    const moldY=cy-moldH/2;
    const moldOpenDist=(phase>=3)?easeO(sat((t-.58)/.14))*W*.10:
                       (phase>=5)?W*.10*(1-ease(sat((t-.88)/.12))):0;
    const fixX=barX+barW+barW*.04;   // fixed half (left)
    const movX=fixX+moldW+moldOpenDist; // moving half (right)

    // Fixed mold (left)
    ctx.fillStyle='#2d3d58'; rrect(fixX,moldY,moldW,moldH,3); ctx.fill();
    hatch(fixX,moldY,moldW,moldH,10,'rgba(255,255,255,.05)');
    ctx.strokeStyle='#4a6088'; ctx.lineWidth=2; rrect(fixX,moldY,moldW,moldH,3); ctx.stroke();

    // Moving mold (right)
    ctx.fillStyle='#2d3d58'; rrect(movX,moldY,moldW,moldH,3); ctx.fill();
    hatch(movX,moldY,moldW,moldH,10,'rgba(255,255,255,.05)');
    ctx.strokeStyle='#4a6088'; ctx.lineWidth=2; rrect(movX,moldY,moldW,moldH,3); ctx.stroke();

    // Cavity gap between halves
    const cavGap=moldOpenDist>1?moldOpenDist:0;
    const cavH=moldH*.45;
    const cavX=fixX+moldW, cavY=cy-cavH/2;
    if(cavGap<5){
      ctx.fillStyle='#0d0f1a'; ctx.fillRect(cavX,cavY,moldW*2,cavH);
    }

    // Sprue channel in fixed mold
    const spH=cavH*.15, spX=fixX, spY=cy-spH/2;
    ctx.fillStyle='#0d0f1a'; ctx.fillRect(spX,spY,moldW+1,spH);

    // Polymer fill
    if(phase>=1){
      const ff=ease(sat((t-.10)/.22));
      const solid=phase>=2?sat((t-.38)/.20):0;
      // Sprue fill
      ctx.fillStyle=`rgb(${lerp(70,180,solid)|0},${lerp(180,180,solid)|0},${lerp(80,80,solid)|0})`;
      ctx.fillRect(spX,spY,moldW*ff+1,spH);
      // Cavity fill (from sprue side, left to right)
      if(ff>.3 && cavGap<5){
        const cff=ease(sat((ff-.3)/.7));
        ctx.fillStyle=`rgb(${lerp(70,180,solid)|0},${lerp(180,180,solid)|0},${lerp(80,80,solid)|0})`;
        ctx.fillRect(cavX,cavY,moldW*cff*2,cavH);
      }
    }

    // Ejector pins
    if(phase>=4){
      const pinAdv=ease(sat((t-.72)/.10))*moldW*.45;
      for(let i=0;i<3;i++){
        const pinY=cavY+cavH*.15+i*cavH*.35;
        ctx.fillStyle='rgba(180,200,230,.8)';
        ctx.fillRect(movX+moldW*.5,pinY,pinAdv,4);
      }
    }

    // ── LABELS ──
    lbl('Barrel',   barX+barW*.4, barY-12,  {align:'center',color:'#5a7090',size:10});
    lbl('Hopper',   hopX,         barY-barH*.9-14,{align:'center',color:'#6878a0',size:10});
    lbl('Fixed Half',  fixX+moldW*.5, moldY-12,{align:'center',color:'#5a7090',size:10});
    lbl('Moving Half', movX+moldW*.5, moldY-12,{align:'center',color:'#5a7090',size:10});
    lbl('Cavity',      fixX+moldW+moldOpenDist*.5+moldW, cy,{align:'center',color:'#6878a0',size:9});
  },
  cleanup(){}
};

// ══════════════════════════════════════
//  MOLDING — BLOW MOLDING
// ══════════════════════════════════════
const BlowMolding = {
  meta:{name:'Blow Molding',mat:'HDPE, PET, PP',temp:'180–250 °C',cat:'Molding'},
  t:0, period:8,
  init(){ this.t=0; },
  onResize(){},
  step(dt){ this.t=(this.t+dt/this.period)%1; },
  draw(){
    grid();
    const cx=W/2, cy=H/2, t=this.t;
    let phase, stageName;
    if(t<.12){phase=0;stageName='Parison extrusion';}
    else if(t<.28){phase=1;stageName='Mold closing';}
    else if(t<.55){phase=2;stageName='Blow inflation';}
    else if(t<.70){phase=3;stageName='Cooling';}
    else if(t<.85){phase=4;stageName='Mold opening';}
    else{phase=5;stageName='Part removal';}
    setStage(stageName,'Blow Molding');

    const mH=Math.min(H*.62,280), mW=Math.min(W*.20,96);
    const mY=cy-mH/2+mH*.10; // shift slightly down (pinch at bottom)

    // Parison (hollow tube extruded from top)
    const parH=(phase<1)?easeO(t/.12)*mH*.80 : mH*.80;
    const parW=mW*.20;
    const parX=cx-parW/2, parY=cy-mH*.35;
    // Extrusion nozzle at top
    ctx.fillStyle='#3a5070';
    rrect(cx-mW*.15,parY-28,mW*.30,28,3); ctx.fill();
    ctx.strokeStyle='#5a7090'; ctx.lineWidth=1.5;
    rrect(cx-mW*.15,parY-28,mW*.30,28,3); ctx.stroke();

    // Blow air inlet
    ctx.fillStyle='#2a3a50';
    ctx.fillRect(cx-4,parY-28-18,8,18);

    // Mold halves
    const moldClose=(phase>=1&&phase<4)?ease(sat((t-.12)/.16)):
                    (phase>=4)?1-ease(sat((t-.70)/.15)):1;
    const moldGap=lerp(mW*.65,0,moldClose);
    // Left mold
    ctx.fillStyle='#2d3d58'; rrect(cx-mW*.5-moldGap,mY,mW*.5,mH,5); ctx.fill();
    hatch(cx-mW*.5-moldGap,mY,mW*.5,mH,10,'rgba(255,255,255,.05)');
    ctx.strokeStyle='#4a6088'; ctx.lineWidth=2; rrect(cx-mW*.5-moldGap,mY,mW*.5,mH,5); ctx.stroke();
    // Right mold
    ctx.fillStyle='#2d3d58'; rrect(cx+moldGap,mY,mW*.5,mH,5); ctx.fill();
    hatch(cx+moldGap,mY,mW*.5,mH,10,'rgba(255,255,255,.05)');
    ctx.strokeStyle='#4a6088'; ctx.lineWidth=2; rrect(cx+moldGap,mY,mW*.5,mH,5); ctx.stroke();

    // Mold inner cavity shape (bottle-like oval cutout)
    if(moldClose>.5){
      const cavW=mW*.48*(2-moldClose), cavH=mH*.82;
      ctx.fillStyle='#0d0f1a';
      ctx.beginPath();
      ctx.ellipse(cx,mY+cavH*.52,cavW*.5,cavH*.5,0,0,Math.PI*2);
      ctx.fill();
    }

    // Parison tube
    if(phase<2){
      ctx.strokeStyle='rgba(70,180,100,.85)'; ctx.lineWidth=parW;
      ctx.beginPath(); ctx.moveTo(cx,parY); ctx.lineTo(cx,parY+parH); ctx.stroke();
    }

    // Inflated part
    if(phase>=2){
      const inflate=ease(sat((t-.28)/.20));
      const bottleW=mW*.44*inflate, bottleH=mH*.78*Math.min(inflate*1.2,1);
      const solid=(phase>=3)?sat((t-.55)/.15):0;
      // Bottle body
      const grd=ctx.createRadialGradient(cx-bottleW*.2,mY+bottleH*.35,1,cx,mY+bottleH*.5,bottleW);
      grd.addColorStop(0,`rgba(100,210,130,${.7+solid*.2})`);
      grd.addColorStop(1,`rgba(30,120,60,${.7+solid*.2})`);
      ctx.beginPath();
      ctx.ellipse(cx, mY+mH*.52, bottleW*.5, bottleH*.5, 0, 0, Math.PI*2);
      ctx.fillStyle=grd; ctx.fill();
      ctx.strokeStyle='rgba(50,160,80,.6)'; ctx.lineWidth=1.5; ctx.stroke();
    }

    // Air blow arrows
    if(phase===2){
      const bFrac=sat((t-.28)/.10);
      arrow(cx,parY-8,cx,parY+20,'#88ccff',2,7);
      lbl('Air pressure',cx+16,parY+8,{align:'left',color:'#88ccff',size:10});
    }

    // ── LABELS ──
    lbl('Extrusion head',cx,parY-46,{align:'center',color:'#5a7090',size:10});
    lbl('Parison',cx+parW+8,parY+parH*.4,{align:'left',color:'#5aaa70',size:10});
    lbl('Mold',cx-mW*.5-moldGap-6,mY+mH*.5,{align:'right',color:'#5a7090',size:10});
    if(moldClose>.7) lbl('Cavity',cx,mY+mH*.88,{align:'center',color:'#6878a0',size:10});
  },
  cleanup(){}
};

// ══════════════════════════════════════
//  MACHINING — TURNING
// ══════════════════════════════════════
const Turning = {
  meta:{name:'Turning (Lathe)',mat:'Metals, Plastics',temp:'Cold – 600 °C',cat:'Machining'},
  t:0, period:6,
  init(){ this.t=0; },
  onResize(){},
  step(dt){ this.t=(this.t+dt/this.period)%1; },
  draw(){
    grid();
    const cx=W/2, cy=H/2, t=this.t;
    const cut=sat(t/.85); // 0→1 as tool advances
    setStage('Turning','Turning');

    const wpR0=Math.min(H*.22,95);   // original radius
    const finalCut=wpR0*.28;
    const r=(x)=>wpR0-finalCut*sat((x-wpStart)/wpLen)*cut; // radius at position x
    const wpLen=Math.min(W*.50,260), wpStart=cx-wpLen*.5;

    // Workpiece body (left to right, radius varies)
    // Draw as filled shape
    ctx.fillStyle='#5b8ab5';
    ctx.strokeStyle='#3a6080'; ctx.lineWidth=2;
    ctx.beginPath();
    const steps=60;
    for(let i=0;i<=steps;i++){
      const x=wpStart+i/steps*wpLen;
      const rad=r(x);
      if(i===0) ctx.moveTo(x,cy-rad);
      else       ctx.lineTo(x,cy-rad);
    }
    for(let i=steps;i>=0;i--){
      const x=wpStart+i/steps*wpLen;
      ctx.lineTo(x,cy+r(x));
    }
    ctx.closePath(); ctx.fill(); ctx.stroke();

    // Rotation marks
    spinMark(wpStart+wpLen*.5, cy, wpR0*.75, t*8, 'rgba(200,220,255,.3)');

    // Chuck (left) simplified as hatched block
    const chuckW=Math.min(W*.07,36);
    ctx.fillStyle='#3a4a60';
    rrect(wpStart-chuckW,cy-wpR0*.6,chuckW,wpR0*1.2,3); ctx.fill();
    ctx.strokeStyle='#5a7090'; ctx.lineWidth=1.5;
    rrect(wpStart-chuckW,cy-wpR0*.6,chuckW,wpR0*1.2,3); ctx.stroke();

    // Tool (approaches from right, cutting upper surface)
    const toolX=wpStart+wpLen*cut;
    const toolTipY=cy-r(toolX);
    const toolW=22, toolH=16;
    ctx.fillStyle='#c8a040'; // carbide insert color
    ctx.beginPath();
    ctx.moveTo(toolX,      toolTipY);
    ctx.lineTo(toolX+toolW,toolTipY-toolH*.5);
    ctx.lineTo(toolX+toolW,toolTipY-toolH*2.5);
    ctx.lineTo(toolX-toolW*.3,toolTipY-toolH*2.5);
    ctx.closePath(); ctx.fill();
    ctx.strokeStyle='#a08030'; ctx.lineWidth=1.5; ctx.stroke();
    // Tool holder
    ctx.fillStyle='#3a4a60';
    ctx.fillRect(toolX-toolW*.3,toolTipY-toolH*3.5,toolW*1.3,toolH);
    ctx.strokeStyle='#5a7090'; ctx.lineWidth=1; ctx.strokeRect(toolX-toolW*.3,toolTipY-toolH*3.5,toolW*1.3,toolH);

    // Chip (curled)
    if(cut>.05){
      ctx.save();
      ctx.strokeStyle='#8a9a60'; ctx.lineWidth=2; ctx.lineCap='round';
      ctx.beginPath();
      for(let a=0;a<Math.PI*2;a+=.15){
        const cr=6+a*2;
        const px=toolX+4+cr*Math.cos(a-Math.PI*.5);
        const py=toolTipY-4-cr*Math.sin(a-Math.PI*.5);
        if(a<.01) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.stroke(); ctx.restore();
    }

    // Depth-of-cut arrow
    if(cut>.1){
      const midX=wpStart+wpLen*.5;
      arrow(midX,cy-wpR0+2,midX,cy-r(midX)+2,'#ffc040',1.5,7);
      lbl(`${(finalCut*cut).toFixed(1)} mm`,midX+8,cy-wpR0+14,{align:'left',color:'#ffc040',size:10});
    }

    // ── LABELS ──
    lbl('Chuck',   wpStart-chuckW*.5,cy-wpR0*.6-14,{align:'center',color:'#5a7090',size:10});
    lbl('Workpiece',cx,cy-wpR0-14,{align:'center',color:'#8090b4',size:11});
    lbl('Cutting Tool',toolX,toolTipY-toolH*4.5,{align:'center',color:'#c8a040',size:10});
    lbl('⟲ Rotation',cx,cy+wpR0+16,{align:'center',color:'rgba(200,220,255,.5)',size:11});
  },
  cleanup(){}
};

// ══════════════════════════════════════
//  MACHINING — MILLING
// ══════════════════════════════════════
const Milling = {
  meta:{name:'Milling',mat:'Metals, Plastics, Composites',temp:'Cold – 500 °C',cat:'Machining'},
  t:0, period:5,
  init(){ this.t=0; },
  onResize(){},
  step(dt){ this.t=(this.t+dt/this.period)%1; },
  draw(){
    grid();
    const cx=W/2, cy=H/2, t=this.t;
    const pos=t; // cutter position 0→1 left-to-right
    setStage('Peripheral milling','Milling');

    const wpW=Math.min(W*.68,380), wpH=Math.min(H*.22,80);
    const wpX=cx-wpW/2, wpY=cy+Math.min(H*.05,20);

    // Surface profile: cutter has already removed material on left
    const cutDepth=wpH*.42;
    const cutterX=lerp(wpX-wpW*.08,wpX+wpW*1.08,pos);
    const doneX=cutterX;

    // Workpiece (draw as two regions: cut and uncut)
    ctx.fillStyle='#5b8ab5'; ctx.strokeStyle='#3a6080'; ctx.lineWidth=2;
    // Uncut portion
    ctx.fillRect(Math.max(wpX,doneX),wpY,Math.max(0,wpX+wpW-doneX),wpH);
    ctx.strokeRect(Math.max(wpX,doneX),wpY,Math.max(0,wpX+wpW-doneX),wpH);
    // Cut (machined) portion
    if(doneX>wpX){
      ctx.fillStyle='#7aadd0';
      ctx.fillRect(wpX,wpY+cutDepth,Math.min(doneX-wpX,wpW),wpH-cutDepth);
      ctx.strokeStyle='#4a8090'; ctx.lineWidth=1.5;
      ctx.strokeRect(wpX,wpY+cutDepth,Math.min(doneX-wpX,wpW),wpH-cutDepth);
    }
    // Workpiece base
    ctx.fillStyle='#3a4a60'; ctx.fillRect(wpX,wpY+wpH,wpW,wpH*.22);
    ctx.strokeStyle='#2a3a50'; ctx.lineWidth=1; ctx.strokeRect(wpX,wpY+wpH,wpW,wpH*.22);

    // ── MILLING CUTTER ──
    const cutterR=Math.min(H*.18,70);
    const cutterCY=wpY-cutterR+cutDepth;
    // Body
    const grd=ctx.createRadialGradient(cutterX-cutterR*.3,cutterCY-cutterR*.3,3,cutterX,cutterCY,cutterR);
    grd.addColorStop(0,'#5a6a80'); grd.addColorStop(1,'#1e2838');
    ctx.beginPath(); ctx.arc(cutterX,cutterCY,cutterR,0,Math.PI*2);
    ctx.fillStyle=grd; ctx.fill();
    ctx.strokeStyle='#5a7090'; ctx.lineWidth=2; ctx.stroke();
    // Flute marks (spinning)
    spinMark(cutterX,cutterCY,cutterR,t*10,'rgba(180,210,255,.4)');
    // Cutting edge inserts
    for(let i=0;i<4;i++){
      const a=i/4*Math.PI*2+t*Math.PI*8;
      const tx=cutterX+cutterR*Math.cos(a), ty=cutterCY+cutterR*Math.sin(a);
      ctx.beginPath(); ctx.arc(tx,ty,4,0,Math.PI*2);
      ctx.fillStyle='#c8a040'; ctx.fill();
    }
    // Arbor
    ctx.fillStyle='#2a3a50';
    ctx.fillRect(cutterX-6, wpY-cutterR*2.2-H*.15, 12, H*.15);

    // Chips flying
    const chipCount=5;
    for(let i=0;i<chipCount;i++){
      const ca=((t*8+i*.6)%1)*Math.PI+Math.PI*.8;
      const cr=cutterR*lerp(.8,1.3,(t*3+i*.4)%1);
      const cpx=cutterX+cr*Math.cos(ca), cpy=cutterCY+cr*Math.sin(ca);
      if(cpy>wpY-5 && cpy<cutterCY+cutterR*.6){
        ctx.beginPath(); ctx.arc(cpx,cpy,2.5,0,Math.PI*2);
        ctx.fillStyle='rgba(160,180,100,.8)'; ctx.fill();
      }
    }

    // Feed direction arrow
    arrow(wpX,wpY-12,wpX+wpW*.15,wpY-12,'#ffc040',2,8);
    lbl('Feed direction',wpX+wpW*.18,wpY-8,{align:'left',color:'#ffc040',size:10});
    lbl('⟲',cutterX,cutterCY,{align:'center',color:'rgba(200,220,255,.5)',size:22});
    lbl('Cutter',cutterX,cutterCY-cutterR-16,{align:'center',color:'#8090b4',size:11});
    lbl('Workpiece',cx,wpY+wpH+30,{align:'center',color:'#8090b4',size:11});
    lbl('Machined surface',wpX+wpW*.3,wpY+cutDepth-10,{align:'center',color:'#7aadd0',size:10});
  },
  cleanup(){}
};

// ══════════════════════════════════════
//  JOINING — ARC WELDING
// ══════════════════════════════════════
const ArcWelding = {
  meta:{name:'Arc Welding (SMAW)',mat:'Structural steel, Stainless',temp:'1400–3500 °C',cat:'Joining'},
  t:0, period:8,
  init(){ this.t=0; },
  onResize(){},
  step(dt){ this.t=(this.t+dt/this.period)%1; },
  draw(){
    grid();
    const cx=W/2, cy=H/2, t=this.t;
    const weldAdv=sat(t/.80); // 0→1 weld progresses left-to-right
    setStage(weldAdv<.05?'Arc struck':weldAdv<.95?'Welding':'Bead complete','Arc Welding');

    const plateW=Math.min(W*.68,360), plateH=Math.min(H*.16,56);
    const plateX=cx-plateW/2;
    const gapY=cy, gapW=plateW*.015;

    // ── WORKPIECE PLATES ──
    // Left plate
    ctx.fillStyle='#5b8ab5';
    rrect(plateX,gapY-plateH,plateX+plateW*.5-gapW/2-plateX,plateH,3); ctx.fill();
    ctx.strokeStyle='#3a6080'; ctx.lineWidth=2;
    rrect(plateX,gapY-plateH,plateX+plateW*.5-gapW/2-plateX,plateH,3); ctx.stroke();
    // Right plate
    ctx.fillStyle='#5b8ab5';
    rrect(cx+gapW/2,gapY-plateH,plateW*.5-gapW/2,plateH,3); ctx.fill();
    ctx.strokeStyle='#3a6080'; ctx.lineWidth=2;
    rrect(cx+gapW/2,gapY-plateH,plateW*.5-gapW/2,plateH,3); ctx.stroke();
    // Heat affected zone gradient (around weld region)
    const weldX=plateX+weldAdv*plateW;
    const hazW=plateW*.14;
    const hazGrd=ctx.createRadialGradient(weldX,gapY,1,weldX,gapY,hazW);
    hazGrd.addColorStop(0,'rgba(255,100,0,.22)');
    hazGrd.addColorStop(1,'rgba(255,100,0,.0)');
    ctx.fillStyle=hazGrd; ctx.fillRect(weldX-hazW,gapY-plateH,hazW*2,plateH);

    // ── SOLIDIFIED WELD BEAD ──
    if(weldAdv>0.03){
      const beadX=plateX, beadLen=(weldAdv-.03)*plateW;
      ctx.fillStyle='#8a4020';
      ctx.beginPath();
      ctx.ellipse(beadX+beadLen*.5, gapY, beadLen*.5, plateH*.28, 0, 0, Math.PI);
      ctx.fill();
      ctx.strokeStyle='#6a3015'; ctx.lineWidth=1; ctx.stroke();
    }

    // Weld pool (glowing orange at current position)
    const poolW=plateH*.60, poolH=plateH*.35;
    const poolGrd=ctx.createRadialGradient(weldX,gapY-poolH*.2,1,weldX,gapY,poolW);
    poolGrd.addColorStop(0,'rgba(255,220,80,.95)');
    poolGrd.addColorStop(.4,'rgba(255,120,0,.85)');
    poolGrd.addColorStop(1,'rgba(255,60,0,.0)');
    ctx.beginPath(); ctx.ellipse(weldX,gapY-poolH*.2,poolW,poolH,0,0,Math.PI);
    ctx.fillStyle=poolGrd; ctx.fill();

    // ── ELECTRODE ──
    const elecLen=Math.min(H*.28,120);
    const elecX=weldX+6, elecTipY=gapY-plateH-Math.min(H*.06,22);
    ctx.save();
    ctx.strokeStyle='#d0c090'; ctx.lineWidth=5;
    ctx.beginPath(); ctx.moveTo(elecX,elecTipY-elecLen); ctx.lineTo(elecX,elecTipY); ctx.stroke();
    // Flux coating
    ctx.strokeStyle='#8a7050'; ctx.lineWidth=9;
    ctx.beginPath(); ctx.moveTo(elecX,elecTipY-elecLen); ctx.lineTo(elecX,elecTipY+4); ctx.stroke();
    ctx.strokeStyle='#d0c090'; ctx.lineWidth=5;
    ctx.beginPath(); ctx.moveTo(elecX,elecTipY-elecLen); ctx.lineTo(elecX,elecTipY); ctx.stroke();
    ctx.restore();

    // ── ARC ──
    const arcFlicker=.9+.1*Math.sin(Date.now()*.04);
    for(let i=0;i<3;i++){
      const ax=elecX+Math.sin(Date.now()*.01+i*2)*4;
      ctx.strokeStyle=`rgba(180,220,255,${(.5+i*.15)*arcFlicker})`;
      ctx.lineWidth=2-i*.5;
      ctx.beginPath(); ctx.moveTo(ax,elecTipY); ctx.lineTo(weldX+Math.sin(Date.now()*.015)*3,gapY-2); ctx.stroke();
    }
    // Arc glow
    const arcGrd=ctx.createRadialGradient(weldX,elecTipY+8,1,weldX,elecTipY+8,28);
    arcGrd.addColorStop(0,'rgba(200,230,255,.35)');
    arcGrd.addColorStop(1,'rgba(200,230,255,0)');
    ctx.fillStyle=arcGrd; ctx.beginPath(); ctx.arc(weldX,elecTipY+8,28,0,Math.PI*2); ctx.fill();

    // Slag layer on bead
    if(weldAdv>.1){
      const slagLen=(weldAdv-.1)*plateW;
      ctx.fillStyle='rgba(60,40,20,.75)';
      ctx.beginPath();
      ctx.ellipse(plateX+slagLen*.5, gapY, slagLen*.5, plateH*.18, 0, 0, Math.PI);
      ctx.fill();
    }

    // ── LABELS ──
    lbl('Electrode',   elecX+10, elecTipY-elecLen*.6,{align:'left',color:'#d0c090',size:10});
    lbl('Arc',         weldX+24, elecTipY+10,         {align:'left',color:'#aacfff',size:10});
    lbl('Weld pool',   weldX+28, gapY-8,              {align:'left',color:'#ff9040',size:10});
    lbl('Slag',        plateX+weldAdv*plateW*.4,gapY+14,{align:'center',color:'#806040',size:10});
    lbl('HAZ',         weldX-hazW*.6,gapY-plateH*.55, {align:'center',color:'rgba(255,100,0,.6)',size:9});
  },
  cleanup(){}
};

// ══════════════════════════════════════
//  JOINING — RESISTANCE SPOT WELDING
// ══════════════════════════════════════
const SpotWelding = {
  meta:{name:'Resistance Spot Welding',mat:'Sheet steel, Al alloys',temp:'1000–1500 °C',cat:'Joining'},
  t:0, period:5,
  init(){ this.t=0; },
  onResize(){},
  step(dt){ this.t=(this.t+dt/this.period)%1; },
  draw(){
    grid();
    const cx=W/2, cy=H/2, t=this.t;
    let phase, stageName;
    if(t<.12){phase=0;stageName='Electrodes positioned';}
    else if(t<.28){phase=1;stageName='Squeeze force applied';}
    else if(t<.55){phase=2;stageName='Current flowing';}
    else if(t<.72){phase=3;stageName='Nugget forming';}
    else if(t<.85){phase=4;stageName='Current off / hold';}
    else{phase=5;stageName='Electrodes retract';}
    setStage(stageName,'Spot Welding');

    const sheetW=Math.min(W*.60,320), sheetH=Math.min(H*.07,24);
    const sheetX=cx-sheetW/2;

    // Electrode dimensions
    const eW=Math.min(W*.07,34), eH=Math.min(H*.22,80);

    // Squeeze: electrodes move inward
    const squeeze=(phase>=1&&phase<5)?ease(sat((t-.12)/.16)):
                  (phase>=5)?1-ease(sat((t-.85)/.15)):0;

    const gapBase=sheetH*.3;
    const topElecY=cy-sheetH-eH-gapBase+gapBase*squeeze;
    const botElecY=cy+sheetH+gapBase-gapBase*squeeze;

    // ── METAL SHEETS ──
    ctx.fillStyle='#5b8ab5';
    ctx.fillRect(sheetX,cy-sheetH,sheetW,sheetH);   // top sheet
    ctx.fillRect(sheetX,cy,       sheetW,sheetH);   // bottom sheet
    ctx.strokeStyle='#3a6080'; ctx.lineWidth=1.5;
    ctx.strokeRect(sheetX,cy-sheetH,sheetW,sheetH);
    ctx.strokeRect(sheetX,cy,       sheetW,sheetH);

    // Faying surface gap line
    ctx.setLineDash([4,4]); ctx.strokeStyle='rgba(120,140,180,.4)'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(sheetX,cy); ctx.lineTo(sheetX+sheetW,cy); ctx.stroke();
    ctx.setLineDash([]);

    // Weld nugget (forms during current phase)
    if(phase>=2){
      const nugGrow=ease(sat((t-.28)/.25));
      const nugR=sheetH*.85*nugGrow;
      const grd=ctx.createRadialGradient(cx,cy,0,cx,cy,nugR);
      grd.addColorStop(0,'rgba(255,200,0,.9)');
      grd.addColorStop(.5,'rgba(255,80,0,.7)');
      grd.addColorStop(1,'rgba(200,60,0,0)');
      ctx.beginPath(); ctx.arc(cx,cy,nugR,0,Math.PI*2);
      ctx.fillStyle=grd; ctx.fill();
    }

    // Solidified nugget (after current off)
    if(phase>=4){
      const solid=sat((t-.55)/.17);
      ctx.beginPath(); ctx.arc(cx,cy,sheetH*.8,0,Math.PI*2);
      ctx.fillStyle=`rgba(160,80,30,${.7*solid})`; ctx.fill();
      ctx.strokeStyle=`rgba(200,100,40,${solid})`; ctx.lineWidth=1.5; ctx.stroke();
    }

    // ── ELECTRODES ──
    function drawElec(ex,ey,flip){
      const tipH=eH*.22;
      ctx.fillStyle='#c0a040';
      ctx.beginPath();
      if(!flip){
        ctx.moveTo(ex-eW*.5,ey); ctx.lineTo(ex+eW*.5,ey);
        ctx.lineTo(ex+eW*.35,ey+tipH); ctx.lineTo(ex-eW*.35,ey+tipH);
      } else {
        ctx.moveTo(ex-eW*.5,ey+eH); ctx.lineTo(ex+eW*.5,ey+eH);
        ctx.lineTo(ex+eW*.35,ey+eH-tipH); ctx.lineTo(ex-eW*.35,ey+eH-tipH);
      }
      ctx.closePath(); ctx.fillStyle='#c0a040'; ctx.fill();
      ctx.strokeStyle='#906020'; ctx.lineWidth=1.5; ctx.stroke();
      // Body
      ctx.fillStyle='#8a7030';
      ctx.fillRect(ex-eW*.35,flip?ey:ey+tipH,eW*.7,eH-tipH);
      ctx.strokeStyle='#5a4820'; ctx.lineWidth=1;
      ctx.strokeRect(ex-eW*.35,flip?ey:ey+tipH,eW*.7,eH-tipH);
      // Cooling water fitting
      ctx.beginPath(); ctx.arc(ex,flip?ey+eH*.8:ey+eH*.2,eW*.12,0,Math.PI*2);
      ctx.fillStyle='#3a6090'; ctx.fill();
    }
    drawElec(cx,topElecY,false);
    drawElec(cx,botElecY,true);

    // Electrode arms
    ctx.fillStyle='#4a5a70';
    ctx.fillRect(cx+eW*.35,topElecY+eH*.35,W*.15,eH*.14);
    ctx.fillRect(cx+eW*.35,botElecY+eH*.51,W*.15,eH*.14);

    // Current flow indicator
    if(phase===2||phase===3){
      const cf=sat((t-.28)/.10);
      for(let i=0;i<5;i++){
        const py=topElecY+eH+(i+.5)/5*(sheetH*2)-1;
        const alpha=(.3+.7*(i===2?.8:.3))*cf;
        ctx.strokeStyle=`rgba(255,220,80,${alpha})`; ctx.lineWidth=2*(i===2?2:1);
        ctx.beginPath(); ctx.moveTo(cx-eW*.15,py); ctx.lineTo(cx+eW*.15,py); ctx.stroke();
      }
      // Down arrow for current
      arrow(cx+eW*.35,topElecY+eH*.5,cx+eW*.35,botElecY+eH*.5,'rgba(255,220,80,.5)',1.5,7);
      lbl('I',cx+eW*.35+12,cy,{align:'left',color:'rgba(255,220,80,.7)',size:12,bold:true});
    }

    // Force arrows
    if(phase>=1&&phase<5){
      const fa=ease(sat((t-.12)/.10));
      arrow(cx,topElecY-18,cx,topElecY,'#ff6060',2,8);
      arrow(cx,botElecY+eH+18,cx,botElecY+eH,'#ff6060',2,8);
    }

    // ── LABELS ──
    lbl('Upper electrode',cx+eW*.6,topElecY+eH*.4,{align:'left',color:'#c0a040',size:10});
    lbl('Lower electrode',cx+eW*.6,botElecY+eH*.6,{align:'left',color:'#c0a040',size:10});
    lbl('Sheet 1',sheetX-6,cy-sheetH*.5+4,{align:'right',color:'#8090b4',size:10});
    lbl('Sheet 2',sheetX-6,cy+sheetH*.5+4, {align:'right',color:'#8090b4',size:10});
    if(phase>=3) lbl('Nugget',cx+sheetH+8,cy+4,{align:'left',color:'#ff9040',size:10});
  },
  cleanup(){}
};

// ══════════════════════════════════════
//  ADDITIVE — FDM
// ══════════════════════════════════════
const FDM = {
  meta:{name:'FDM (Fused Deposition)',mat:'PLA, ABS, PETG, Nylon',temp:'180–260 °C',cat:'Additive'},
  t:0, period:10, layers:[], curLayer:0,
  init(){
    this.t=0; this.layers=[]; this.curLayer=0;
  },
  onResize(){ this.init(); },
  step(dt){
    this.t=(this.t+dt/this.period)%1;
    const totalLayers=10;
    const layerFrac=this.t*totalLayers;
    this.curLayer=Math.floor(layerFrac);
    this.layerProg=layerFrac-this.curLayer;
    setStage(`Layer ${this.curLayer+1} / ${totalLayers}`,'FDM');
  },
  draw(){
    grid();
    const cx=W/2, cy=H/2, t=this.t;
    const totalLayers=10;
    const partW=Math.min(W*.38,200), partH0=Math.min(H*.40,160);
    const bedW=Math.min(W*.60,320), bedH=Math.min(H*.06,18);
    const bedX=cx-bedW/2, bedY=cy+partH0*.55;

    // Print bed
    ctx.fillStyle='#2d3d58';
    rrect(bedX,bedY,bedW,bedH,3); ctx.fill();
    hatch(bedX,bedY,bedW,bedH,6,'rgba(255,255,255,.07)');
    ctx.strokeStyle='#4a6088'; ctx.lineWidth=2; rrect(bedX,bedY,bedW,bedH,3); ctx.stroke();
    // Bed surface
    ctx.fillStyle='#3a5070'; ctx.fillRect(bedX,bedY,bedW,bedH*.3);

    // ── PRINTED LAYERS ──
    const layerH=partH0/totalLayers;
    const completeLayers=this.curLayer;
    const layProg=this.layerProg;

    // Part colors per layer (alternating slightly for visual interest)
    const layerColors=['#e85c30','#e86430','#dd5828','#d54e22','#cc4820',
                       '#c84220','#c03c1e','#b8381c','#b0341a','#a83018'];

    for(let l=0;l<completeLayers;l++){
      const ly=bedY-layerH*(l+1);
      // Full layer
      ctx.fillStyle=layerColors[l%layerColors.length];
      ctx.fillRect(cx-partW/2,ly,partW,layerH);
      ctx.strokeStyle='rgba(60,20,10,.4)'; ctx.lineWidth=.5;
      ctx.strokeRect(cx-partW/2,ly,partW,layerH);
      // Perimeter lines
      ctx.strokeStyle='rgba(0,0,0,.25)'; ctx.lineWidth=1;
      ctx.strokeRect(cx-partW/2+1.5,ly,partW-3,layerH);
    }

    // Current layer (partial — nozzle sweeping)
    if(completeLayers<totalLayers){
      const ly=bedY-layerH*(completeLayers+1);
      const curW=partW*layProg;
      ctx.fillStyle=layerColors[completeLayers%layerColors.length];
      ctx.fillRect(cx-partW/2,ly,curW,layerH);
    }

    // ── NOZZLE ──
    const nozzX=cx-partW/2+partW*layProg;
    const nozzY=bedY-layerH*(completeLayers+1)-2;

    // Gantry rod
    ctx.fillStyle='#3a4a60';
    ctx.fillRect(bedX,nozzY-Math.min(H*.12,48),bedW,8);
    ctx.strokeStyle='#5a7090'; ctx.lineWidth=1; ctx.strokeRect(bedX,nozzY-Math.min(H*.12,48),bedW,8);

    // Hot-end body
    ctx.fillStyle='#4a5a70';
    rrect(nozzX-10,nozzY-Math.min(H*.09,36),20,Math.min(H*.09,36)-10,3); ctx.fill();
    ctx.strokeStyle='#6878a0'; ctx.lineWidth=1.5;
    rrect(nozzX-10,nozzY-Math.min(H*.09,36),20,Math.min(H*.09,36)-10,3); ctx.stroke();
    // Heater block (orange glow)
    const hbH=12;
    ctx.fillStyle='#c04010';
    ctx.fillRect(nozzX-8,nozzY-hbH,16,hbH);
    ctx.strokeStyle='#e05020'; ctx.lineWidth=1; ctx.strokeRect(nozzX-8,nozzY-hbH,16,hbH);
    // Nozzle tip
    ctx.fillStyle='#8a9aaa';
    ctx.beginPath();
    ctx.moveTo(nozzX-6,nozzY); ctx.lineTo(nozzX+6,nozzY);
    ctx.lineTo(nozzX+2,nozzY+10); ctx.lineTo(nozzX-2,nozzY+10);
    ctx.closePath(); ctx.fill();

    // Filament exiting nozzle
    if(completeLayers<totalLayers){
      ctx.strokeStyle='rgba(200,80,30,.8)'; ctx.lineWidth=3;
      ctx.beginPath(); ctx.moveTo(nozzX,nozzY+10); ctx.lineTo(nozzX,nozzY+14); ctx.stroke();
    }

    // Filament spool (right side)
    const spoolCX=bedX+bedW+Math.min(W*.08,38), spoolCY=cy-partH0*.2;
    const spoolR=Math.min(H*.09,32);
    const grd=ctx.createRadialGradient(spoolCX,spoolCY,spoolR*.3,spoolCX,spoolCY,spoolR);
    grd.addColorStop(0,'#4a5a70'); grd.addColorStop(1,'#1e2838');
    ctx.beginPath(); ctx.arc(spoolCX,spoolCY,spoolR,0,Math.PI*2);
    ctx.fillStyle=grd; ctx.fill(); ctx.strokeStyle='#5a7090'; ctx.lineWidth=2; ctx.stroke();
    ctx.beginPath(); ctx.arc(spoolCX,spoolCY,spoolR*.35,0,Math.PI*2);
    ctx.fillStyle='#0d0f1a'; ctx.fill();
    // Filament path to nozzle
    ctx.strokeStyle='rgba(200,80,30,.5)'; ctx.lineWidth=2; ctx.setLineDash([4,4]);
    ctx.beginPath(); ctx.moveTo(spoolCX,spoolCY-spoolR); ctx.lineTo(nozzX,nozzY-Math.min(H*.09,36)); ctx.stroke();
    ctx.setLineDash([]);

    // ── LABELS ──
    lbl('Print Head', nozzX,nozzY-Math.min(H*.09,36)-14,{align:'center',color:'#8090b4',size:10});
    lbl('Filament',   spoolCX,spoolCY+spoolR+14,        {align:'center',color:'#8090b4',size:10});
    lbl('Print Bed',  bedX+bedW*.5,bedY+bedH+14,        {align:'center',color:'#5a7090',size:10});
    lbl(`Height: ${(completeLayers*layerH).toFixed(0)} px`,cx,bedY-partH0-22,{color:'#6878a0',size:10});
  },
  cleanup(){}
};

// ══════════════════════════════════════
//  ADDITIVE — SLA (Stereolithography)
// ══════════════════════════════════════
const SLA = {
  meta:{name:'SLA (Stereolithography)',mat:'UV-curable photopolymer',temp:'Room temperature',cat:'Additive'},
  t:0, period:10, totalLayers:12,
  init(){ this.t=0; },
  onResize(){},
  step(dt){
    this.t=(this.t+dt/this.period)%1;
    const lf=this.t*this.totalLayers;
    this.curLayer=Math.floor(lf); this.layerProg=lf-this.curLayer;
    setStage(`Layer ${this.curLayer+1} / ${this.totalLayers}`,'SLA');
  },
  draw(){
    grid();
    const cx=W/2, cy=H/2;
    const vatW=Math.min(W*.52,280), vatH=Math.min(H*.56,240);
    const vatX=cx-vatW/2, vatY=cy-vatH*.35;
    const totalLayers=this.totalLayers;
    const layerH=vatH*.65/totalLayers;
    const partW=vatW*.55;

    // ── RESIN VAT ──
    // Back wall + bottom
    ctx.fillStyle='rgba(30,50,80,.5)';
    rrect(vatX,vatY,vatW,vatH,5); ctx.fill();
    ctx.strokeStyle='#3a5a88'; ctx.lineWidth=2; rrect(vatX,vatY,vatW,vatH,5); ctx.stroke();
    // Resin liquid (semi-transparent blue)
    const resinTop=vatY+vatH*.10;
    const resinBot=vatY+vatH*.92;
    ctx.fillStyle='rgba(20,60,120,.55)';
    ctx.fillRect(vatX+2,resinTop,vatW-4,resinBot-resinTop);
    // Resin surface shimmer
    ctx.strokeStyle='rgba(100,180,255,.25)'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(vatX+2,resinTop); ctx.lineTo(vatX+vatW-2,resinTop); ctx.stroke();

    // ── BUILD PLATFORM (rises each layer) ──
    const doneH=layerH*(this.curLayer+this.layerProg);
    const platW=vatW*.80, platH=8;
    const platX=cx-platW/2;
    const platY=resinBot-doneH-platH;
    // Platform support rod
    ctx.fillStyle='#3a4a60';
    ctx.fillRect(cx-4,vatY-Math.min(H*.12,50),8,platY-(vatY-Math.min(H*.12,50))+2);
    ctx.strokeStyle='#5a7090'; ctx.lineWidth=1;
    ctx.strokeRect(cx-4,vatY-Math.min(H*.12,50),8,platY-(vatY-Math.min(H*.12,50))+2);
    // Motor/linear rail at top
    ctx.fillStyle='#2d3d58';
    rrect(cx-Math.min(W*.08,40),vatY-Math.min(H*.14,58),Math.min(W*.16,80),Math.min(H*.07,24),4); ctx.fill();
    ctx.strokeStyle='#4a6088'; ctx.lineWidth=1.5;
    rrect(cx-Math.min(W*.08,40),vatY-Math.min(H*.14,58),Math.min(W*.16,80),Math.min(H*.07,24),4); ctx.stroke();
    lbl('Z axis motor',cx,vatY-Math.min(H*.14,58)-10,{align:'center',color:'#5a7090',size:9});

    // Platform
    ctx.fillStyle='#4a5a70';
    ctx.fillRect(platX,platY,platW,platH);
    ctx.strokeStyle='#6878a0'; ctx.lineWidth=1.5;
    ctx.strokeRect(platX,platY,platW,platH);

    // ── PRINTED LAYERS ──
    for(let l=0;l<this.curLayer;l++){
      const ly=platY+platH+l*layerH;
      const a=lerp(.5,.85,l/totalLayers);
      ctx.fillStyle=`rgba(180,80,220,${a})`;
      ctx.fillRect(cx-partW/2,ly,partW,layerH);
      ctx.strokeStyle='rgba(100,40,140,.4)'; ctx.lineWidth=.5;
      ctx.strokeRect(cx-partW/2,ly,partW,layerH);
    }
    // Partial current layer (UV curing flash)
    const curLayY=platY+platH+this.curLayer*layerH;
    const cureW=partW*this.layerProg;
    ctx.fillStyle='rgba(210,100,255,.65)';
    ctx.fillRect(cx-partW/2,curLayY,cureW,layerH);

    // ── UV LASER ──
    const laserX=cx-partW/2+partW*this.layerProg;
    const laserSrcY=vatY-Math.min(H*.25,100);
    // Laser source
    ctx.fillStyle='#5a3080';
    rrect(laserX-14,laserSrcY-16,28,16,3); ctx.fill();
    ctx.strokeStyle='#8a50cc'; ctx.lineWidth=1.5;
    rrect(laserX-14,laserSrcY-16,28,16,3); ctx.stroke();
    lbl('UV Laser',laserX,laserSrcY-28,{align:'center',color:'#aa70ee',size:10});

    // Laser beam
    const beamGrd=ctx.createLinearGradient(laserX,laserSrcY,laserX,curLayY+layerH);
    beamGrd.addColorStop(0,'rgba(180,80,255,.6)');
    beamGrd.addColorStop(1,'rgba(180,80,255,.15)');
    ctx.strokeStyle=beamGrd; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(laserX,laserSrcY); ctx.lineTo(laserX,curLayY+layerH*.5); ctx.stroke();
    // Beam spot glow
    const spotGrd=ctx.createRadialGradient(laserX,curLayY+layerH*.5,0,laserX,curLayY+layerH*.5,10);
    spotGrd.addColorStop(0,'rgba(220,150,255,.9)');
    spotGrd.addColorStop(1,'rgba(220,150,255,0)');
    ctx.fillStyle=spotGrd; ctx.beginPath(); ctx.arc(laserX,curLayY+layerH*.5,10,0,Math.PI*2); ctx.fill();

    // Up-arrow (platform rising)
    arrow(platX-16,platY+platH*2,platX-16,platY,'#ffc040',1.5,7);
    lbl('↑ Rise',platX-28,platY+platH,'#ffc040',{align:'right',size:10});

    // ── LABELS ──
    lbl('Build Platform',cx,platY-10,{align:'center',color:'#6878a0',size:10});
    lbl('Resin Vat',vatX+vatW+10,vatY+vatH*.5,{align:'left',color:'#4a7aaa',size:10});
    lbl('Cured polymer',cx,curLayY-10,{align:'center',color:'#cc80ff',size:10});
  },
  cleanup(){}
};

// ══════════════════════════════════════
//  PROCESS DETAILS  (pros / cons / complexity / tolerance)
// ══════════════════════════════════════
const DETAILS = {
  sandCasting: {
    pros:['Low tooling cost — ideal for prototypes and short runs',
          'Very large and highly complex shapes possible',
          'Widest material range — nearly any metal or alloy'],
    cons:['Rough surface finish (~Ra 12–25 µm) needs machining',
          'Loose tolerances (±1–3 mm) compared to other processes',
          'Slow cycle time — one mold consumed per casting'],
    complexity:'High — complex 3D shapes including internal cavities via cores',
    tolerance:'±1–3 mm',
  },
  investmentCasting: {
    pros:['Near-net shape — excellent dimensional accuracy',
          'Very smooth surface finish (~Ra 1.5–3 µm)',
          'Intricate geometries, thin walls, undercuts possible'],
    cons:['High tooling and per-part cost',
          'Part size limited (typically < 25 kg)',
          'Longer lead time than sand or die casting'],
    complexity:'Very High — intricate 3D geometries, thin walls, undercuts',
    tolerance:'±0.1–0.5 mm',
  },
  dieCasting: {
    pros:['High production rate — short cycle times',
          'Good surface finish and consistent tolerances',
          'Excellent for thin-walled, lightweight parts'],
    cons:['High die cost — only economical at high volumes',
          'Limited to low-melting alloys (Zn, Al, Mg)',
          'Porosity risk from trapped air during injection'],
    complexity:'Moderate–High — complex shapes; undercuts require side actions',
    tolerance:'±0.1–0.3 mm',
  },
  rolling: {
    pros:['Very high production rate — continuous process',
          'Improves mechanical properties via work hardening',
          'Low cost per unit at volume'],
    cons:['Limited to uniform cross-sections (sheet, plate, rod)',
          'Residual stresses may cause warping after forming',
          'Large capital investment for rolling mill equipment'],
    complexity:'Low — flat/sheet or simple prismatic profiles only',
    tolerance:'±0.1–0.5 mm (sheet thickness)',
  },
  forging: {
    pros:['Superior mechanical properties — refined grain flow',
          'High strength-to-weight ratio',
          'Excellent fatigue and impact resistance'],
    cons:['High tooling cost for closed-die forging',
          'Limited to relatively simple solid shapes',
          'Not all alloys are easily forgeable'],
    complexity:'Moderate — solid shapes without undercuts; open-die is more flexible',
    tolerance:'±0.5–2 mm',
  },
  extrusion: {
    pros:['Long continuous parts with constant cross-section',
          'Wide range of profile shapes achievable',
          'Good surface finish and work-hardened properties'],
    cons:['Cross-section must remain constant along the length',
          'Part length limited by press and billet capacity',
          'Complex profiles require expensive tooling'],
    complexity:'Low — constant cross-section profiles only; no length-wise variation',
    tolerance:'±0.1–0.5 mm',
  },
  injectionMolding: {
    pros:['Extremely high production rate — short cycle times',
          'Excellent surface finish and tight repeatability',
          'Complex 3D geometries achievable in one shot'],
    cons:['Very high mold cost — needs high volume to justify',
          'Limited mainly to polymers and composites',
          'Uniform wall thickness required for quality parts'],
    complexity:'High — complex 3D shapes; undercuts possible with side actions',
    tolerance:'±0.05–0.2 mm',
  },
  blowMolding: {
    pros:['Efficient for hollow thin-walled containers',
          'High production rate with low cost per part',
          'Lightweight parts with seamless construction'],
    cons:['Restricted to hollow shapes only',
          'Wall thickness difficult to control uniformly',
          'Limited to thermoplastic materials'],
    complexity:'Low–Moderate — hollow shapes only; no solid or open sections',
    tolerance:'±0.3–1 mm',
  },
  turning: {
    pros:['High dimensional accuracy and surface finish',
          'Versatile — wide range of materials',
          'Precise control of diameters, shoulders, threads'],
    cons:['Limited to rotationally symmetric geometries',
          'Significant material waste (subtractive process)',
          'Asymmetric features require additional milling'],
    complexity:'Moderate — rotationally symmetric shapes; asymmetric features need milling',
    tolerance:'±0.01–0.05 mm',
  },
  milling: {
    pros:['Complex 3D surfaces, pockets, and contours',
          'Wide material range including metals, ceramics, composites',
          'Excellent dimensional accuracy and surface finish'],
    cons:['Slow compared to forming or casting at high volumes',
          'High material waste (subtractive process)',
          'Complex toolpaths require skilled programming (CAM)'],
    complexity:'High — complex 3D surfaces, pockets, slots, contours',
    tolerance:'±0.01–0.05 mm',
  },
  arcWelding: {
    pros:['Strong permanent joints — can match base material strength',
          'Versatile — various alloys and joint geometries',
          'Portable, relatively low equipment cost'],
    cons:['Heat-affected zone (HAZ) alters material properties',
          'Distortion and residual stresses from thermal cycling',
          'Quality depends heavily on operator skill'],
    complexity:'Moderate — joins complex assemblies; limited by access and fit-up',
    tolerance:'±0.5–2 mm (joint position)',
  },
  spotWelding: {
    pros:['Very fast — easily automated for high production',
          'No filler material needed, clean process',
          'Repeatable and consistent for sheet metal assembly'],
    cons:['Limited to sheet metal in an overlap joint configuration',
          'Cannot weld all material combinations',
          'Access to both sides of the joint required'],
    complexity:'Low — sheet metal overlap joints only',
    tolerance:'±0.5–1 mm',
  },
  fdm: {
    pros:['Any geometry — no tooling or dies required',
          'Low cost for prototypes and short production runs',
          'Wide material range (PLA, ABS, PEEK, TPU, etc.)'],
    cons:['Anisotropic properties — weaker between layers',
          'Visible layer lines; post-processing often needed',
          'Slow build speed compared to subtractive methods'],
    complexity:'Very High — any geometry including internal channels and lattices',
    tolerance:'±0.1–0.3 mm',
  },
  sla: {
    pros:['Excellent surface finish — smooth and detailed',
          'Very high feature resolution and accuracy',
          'Complex overhanging geometries with support structures'],
    cons:['Limited to photopolymer resins (often brittle)',
          'Parts degrade with UV exposure over time',
          'Build volume limited; resin is expensive'],
    complexity:'Very High — intricate geometries, fine features, thin walls',
    tolerance:'±0.05–0.15 mm',
  },
};

// ══════════════════════════════════════
//  REGISTRY
// ══════════════════════════════════════
const CATEGORIES = {
  casting:  { label:'Casting',    subs:['sandCasting','investmentCasting','dieCasting'] },
  forming:  { label:'Forming',    subs:['rolling','forging','extrusion'] },
  molding:  { label:'Molding',    subs:['injectionMolding','blowMolding'] },
  machining:{ label:'Machining',  subs:['turning','milling'] },
  joining:  { label:'Joining',    subs:['arcWelding','spotWelding'] },
  additive: { label:'Additive',   subs:['fdm','sla'] },
};

const SIMS = {
  sandCasting:       { label:'Sand Casting',       sim:SandCasting },
  investmentCasting: { label:'Investment Casting', sim:InvestmentCasting },
  dieCasting:        { label:'Die Casting',        sim:DieCasting },
  rolling:        { label:'Rolling',         sim:Rolling },
  forging:        { label:'Forging',         sim:Forging },
  extrusion:      { label:'Extrusion',       sim:Extrusion },
  injectionMolding:{ label:'Injection Molding', sim:InjectionMolding },
  blowMolding:    { label:'Blow Molding',    sim:BlowMolding },
  turning:        { label:'Turning (Lathe)', sim:Turning },
  milling:        { label:'Milling',         sim:Milling },
  arcWelding:     { label:'Arc Welding',     sim:ArcWelding },
  spotWelding:    { label:'Resistance Spot Welding', sim:SpotWelding },
  fdm:            { label:'FDM 3D Printing', sim:FDM },
  sla:            { label:'SLA / Resin',     sim:SLA },
};

// ══════════════════════════════════════
//  UI LOGIC
// ══════════════════════════════════════
let currentCat='casting', currentSubKey='sandCasting';

function selectCategory(cat){
  currentCat=cat;
  document.querySelectorAll('.cat-btn').forEach(b=>b.classList.toggle('active',b.dataset.cat===cat));
  buildSubMenu(cat);
  const firstSub=CATEGORIES[cat].subs[0];
  selectSub(firstSub);
}

function buildSubMenu(cat){
  const grid=document.getElementById('sub-grid');
  grid.innerHTML='';
  CATEGORIES[cat].subs.forEach(key=>{
    const btn=document.createElement('button');
    btn.className='sub-btn';
    btn.textContent=SIMS[key].label;
    btn.dataset.sub=key;
    btn.addEventListener('click',()=>selectSub(key));
    grid.appendChild(btn);
  });
}

function selectSub(key){
  currentSubKey=key;
  document.querySelectorAll('.sub-btn').forEach(b=>b.classList.toggle('active',b.dataset.sub===key));
  const entry=SIMS[key];
  loadSim(entry.sim);
}

// ── BUTTON EVENTS ──
document.querySelectorAll('.cat-btn').forEach(b=>{
  b.addEventListener('click',()=>selectCategory(b.dataset.cat));
});

document.getElementById('btn-play').addEventListener('click',function(){
  running=!running;
  this.textContent=running?'⏸ Pause':'▶ Play';
  this.classList.toggle('running',running);
});

document.getElementById('btn-reset').addEventListener('click',()=>{
  if(currentSim) currentSim.init();
});

document.getElementById('spd-slider').addEventListener('input',function(){
  speed=parseFloat(this.value);
  document.getElementById('spd-val').textContent=`${speed}×`;
});

// ── INIT ──
selectCategory('casting');
lastTs=performance.now();
animId=requestAnimationFrame(animate);
</script>
</body>
</html>
